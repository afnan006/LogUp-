Ingestion Results for e:\LogUp\backend
Summary
Directory: backend
Files analyzed: 98

Estimated tokens: 59.3k


Directory structure:
└── backend/
    ├── README.md
    ├── ca.pem
    ├── IngestBackend 1.txt
    ├── IngestBackend 2.txt
    ├── main.py
    ├── requirements.txt
    ├── app/
    │   ├── __init__.py
    │   ├── __pycache__/
    │   ├── api/
    │   │   ├── __init__.py
    │   │   ├── analytics.py
    │   │   ├── auth.py
    │   │   ├── budgets.py
    │   │   ├── chat.py
    │   │   ├── dashboard.py
    │   │   ├── debts.py
    │   │   ├── friends.py
    │   │   ├── goals.py
    │   │   ├── messages.py
    │   │   ├── notifications.py
    │   │   ├── permissions.py
    │   │   ├── receipts.py
    │   │   ├── savings.py
    │   │   ├── sms.py
    │   │   ├── split_expenses.py
    │   │   ├── subscriptions.py
    │   │   ├── templates.py
    │   │   ├── transactions.py
    │   │   ├── widgets.py
    │   │   └── __pycache__/
    │   ├── config/
    │   │   ├── __init__.py
    │   │   └── settings.py
    │   ├── db/
    │   │   ├── __init__.py
    │   │   ├── create_tables.py
    │   │   ├── database.py
    │   │   ├── test_db_connection.py
    │   │   ├── __pycache__/
    │   │   ├── models/
    │   │   │   ├── __init__.py
    │   │   │   ├── budget.py
    │   │   │   ├── debt.py
    │   │   │   ├── friend.py
    │   │   │   ├── goal.py
    │   │   │   ├── message.py
    │   │   │   ├── nudge.py
    │   │   │   ├── permission.py
    │   │   │   ├── saving.py
    │   │   │   ├── split_expense.py
    │   │   │   ├── subscription.py
    │   │   │   ├── template.py
    │   │   │   ├── transaction.py
    │   │   │   ├── user.py
    │   │   │   ├── widget_config.py
    │   │   │   └── __pycache__/
    │   │   └── schemas/
    │   │       ├── __init__.py
    │   │       ├── budget.py
    │   │       ├── debt.py
    │   │       ├── friend.py
    │   │       ├── goal.py
    │   │       ├── message.py
    │   │       ├── nudge.py
    │   │       ├── permission.py
    │   │       ├── saving.py
    │   │       ├── split_expense.py
    │   │       ├── subscription.py
    │   │       ├── template.py
    │   │       ├── transaction.py
    │   │       ├── user.py
    │   │       ├── widget_config.py
    │   │       └── __pycache__/
    │   ├── middleware/
    │   │   ├── __init__.py
    │   │   └── auth.py
    │   ├── services/
    │   │   ├── __init__.py
    │   │   ├── analytics_service.py
    │   │   ├── auth_service.py
    │   │   ├── budget_service.py
    │   │   ├── chat_service.py
    │   │   ├── debt_service.py
    │   │   ├── friend_service.py
    │   │   ├── goal_service.py
    │   │   ├── message_service.py
    │   │   ├── notification_service.py
    │   │   ├── split_service.py
    │   │   ├── subscription_service.py
    │   │   └── transaction_service.py
    │   └── utils/
    │       ├── __init__.py
    │       └── helpers.py
    └── tests/
        ├── __init__.py
        ├── test_analytics.py
        ├── test_auth.py
        ├── test_budgets.py
        ├── test_chat.py
        ├── test_debts.py
        ├── test_friends.py
        ├── test_goals.py
        ├── test_messages.py
        ├── test_notifications.py
        ├── test_nudges.py
        ├── test_receipts.py
        ├── test_savings.py
        ├── test_sms.py
        ├── test_split_expenses.py
        ├── test_subscriptions.py
        ├── test_templates.py
        ├── test_transactions.py
        └── __pycache__/


File Contents

===============================================
File: README.md
===============================================



===============================================
File: ca.pem
===============================================

-----BEGIN CERTIFICATE-----
MIIEUDCCArigAwIBAgIUCO+u/6m7BQ+0IK13DE3KPKxxUVYwDQYJKoZIhvcNAQEM
BQAwQDE+MDwGA1UEAww1MDEzMWMwNTUtMWE1Mi00ZGI3LTg0MmYtYTBmYWU2NWNm
NDAyIEdFTiAxIFByb2plY3QgQ0EwHhcNMjUwNzMwMTAxMTEwWhcNMzUwNzI4MTAx
MTEwWjBAMT4wPAYDVQQDDDUwMTMxYzA1NS0xYTUyLTRkYjctODQyZi1hMGZhZTY1
Y2Y0MDIgR0VOIDEgUHJvamVjdCBDQTCCAaIwDQYJKoZIhvcNAQEBBQADggGPADCC
AYoCggGBAJKoICvm6A1XcaD+ouLn+1TM40WJOjWJ6E8nhAnzv8VFjrhlAJkPgf3x
xy52erloS4A0YT+tjCVycSAwMePk+09rKMPzdwOFtL3g0C4AqxxRPNbEGi/Aeidc
MPQ5Ry05nrzISOm/bD6usx1Wn/lHvMhS1ZIOSz0pStSWllPv3PiOViEuiHk2EJcK
OT7QGYkG4L3UEwPULL9gArIMxP+fZKliPqzzSjHx7aBhpjZhybXawYpzVfZ5yp+j
1phO50zXRfO1RmFdGX9e6bjz5YNoNX0xmo7Ka+MIyyEU0TjcogQ+O2W9SQGff7af
GSjamxJdULtR3WzwPQIc1ucLskGK10sbUzC3qqZgoZB5uty/M+TEKHsVA63BVjQ0
aPAUw1zD+6RA1Ph95YFCrKR0ROE/0MfLzhLF4wzqBTbsxvYMMU2O+WR/8yoHg6AN
ENRys1DqtGcnxZk+h24tiGDknN7OZxNdO22AiML4yI1CiiYUE2Sfyhut0Uc42me+
bl/m7VCgZwIDAQABo0IwQDAdBgNVHQ4EFgQUGJ+lgcBl0l2/mgBSlmO2DiCBcLIw
EgYDVR0TAQH/BAgwBgEB/wIBADALBgNVHQ8EBAMCAQYwDQYJKoZIhvcNAQEMBQAD
ggGBAE3N5hGtLfkFbf92d0hogWRh6MSGkX/E09z+CGIO/+PJLgFXXp5PeRbUiHJB
oaTNxfW/0HBP6v5aNaVXdGvFTH1Ft1Z+5miTQmKhMc5Ug+e1e1kbqZZam/2cs/Bh
Zcm0JgkbDOzI/rl49bpeBG+ggd4a1bST6SQlV8oHOdbk4fpwwmOgyCMpDCdOcu2y
QVaiwFhkCJLusf1KMTkBW/eghTYA6qjj9TKLmBn8Z5zwiBIifXAKDJvG1wiJttzB
9p1U85u5wWpeSie0Rw3Y/H7ysm48qOXAy33BwHXcJkjxjct6Jdeud+N1ENMHxgIu
GDfbITNrF5FS9vCZ0ugJqrt6OTXYq7AbVWV6OWYAn7vakmjUvNK7NTxtmu12Chx7
L050MAgCaoFNOjHqnOSB85OjJKSeOt9b2wgjnDEQqKco3CqhrR5kGAeYF6+s1JM5
ky/wvDyxNEAB4FItRWWNNQBmucTVwWNKE55T3fiYH12jrWGjwIVGsABLWOofCsof
qg4R+A==
-----END CERTIFICATE-----


===============================================
File: IngestBackend 1.txt
===============================================

Ingestion Results for e:\LogUp\backend
Summary
Directory: backend
Files analyzed: 94

Estimated tokens: 5.0k


Directory structure:
└── backend/
    ├── README.md
    ├── ca.pem
    ├── main.py
    ├── requirements.txt
    ├── app/
    │   ├── __init__.py
    │   ├── __pycache__/
    │   ├── api/
    │   │   ├── __init__.py
    │   │   ├── analytics.py
    │   │   ├── auth.py
    │   │   ├── budgets.py
    │   │   ├── chat.py
    │   │   ├── dashboard.py
    │   │   ├── debts.py
    │   │   ├── friends.py
    │   │   ├── goals.py
    │   │   ├── messages.py
    │   │   ├── notifications.py
    │   │   ├── permissions.py
    │   │   ├── receipts.py
    │   │   ├── savings.py
    │   │   ├── sms.py
    │   │   ├── split_expenses.py
    │   │   ├── subscriptions.py
    │   │   ├── templates.py
    │   │   ├── transactions.py
    │   │   └── widgets.py
    │   ├── config/
    │   │   ├── __init__.py
    │   │   └── settings.py
    │   ├── db/
    │   │   ├── __init__.py
    │   │   ├── database.py
    │   │   ├── test_db_connection.py
    │   │   ├── __pycache__/
    │   │   ├── models/
    │   │   │   ├── __init__.py
    │   │   │   ├── budget.py
    │   │   │   ├── debt.py
    │   │   │   ├── friend.py
    │   │   │   ├── goal.py
    │   │   │   ├── message.py
    │   │   │   ├── nudge.py
    │   │   │   ├── permission.py
    │   │   │   ├── saving.py
    │   │   │   ├── split_expense.py
    │   │   │   ├── subscription.py
    │   │   │   ├── template.py
    │   │   │   ├── transaction.py
    │   │   │   ├── user.py
    │   │   │   └── widget_config.py
    │   │   └── schemas/
    │   │       ├── __init__.py
    │   │       ├── budget.py
    │   │       ├── debt.py
    │   │       ├── friend.py
    │   │       ├── goal.py
    │   │       ├── message.py
    │   │       ├── nudge.py
    │   │       ├── permission.py
    │   │       ├── saving.py
    │   │       ├── split_expense.py
    │   │       ├── subscription.py
    │   │       ├── template.py
    │   │       ├── transaction.py
    │   │       ├── user.py
    │   │       └── widget_config.py
    │   ├── middleware/
    │   │   ├── __init__.py
    │   │   └── auth.py
    │   ├── services/
    │   │   ├── __init__.py
    │   │   ├── analytics_service.py
    │   │   ├── auth_service.py
    │   │   ├── budget_service.py
    │   │   ├── chat_service.py
    │   │   ├── debt_service.py
    │   │   ├── friend_service.py
    │   │   ├── goal_service.py
    │   │   ├── message_service.py
    │   │   ├── notification_service.py
    │   │   ├── split_service.py
    │   │   ├── subscription_service.py
    │   │   └── transaction_service.py
    │   └── utils/
    │       ├── __init__.py
    │       └── helpers.py
    └── tests/
        ├── __init__.py
        ├── test_analytics.py
        ├── test_auth.py
        ├── test_budgets.py
        ├── test_chat.py
        ├── test_debts.py
        ├── test_friends.py
        ├── test_goals.py
        ├── test_messages.py
        ├── test_notifications.py
        ├── test_receipts.py
        ├── test_savings.py
        ├── test_sms.py
        ├── test_split_expenses.py
        ├── test_subscriptions.py
        ├── test_templates.py
        └── test_transactions.py


File Contents

===============================================
File: README.md
===============================================



===============================================
File: ca.pem
===============================================

-----BEGIN CERTIFICATE-----
MIIEUDCCArigAwIBAgIUCO+u/6m7BQ+0IK13DE3KPKxxUVYwDQYJKoZIhvcNAQEM
BQAwQDE+MDwGA1UEAww1MDEzMWMwNTUtMWE1Mi00ZGI3LTg0MmYtYTBmYWU2NWNm
NDAyIEdFTiAxIFByb2plY3QgQ0EwHhcNMjUwNzMwMTAxMTEwWhcNMzUwNzI4MTAx
MTEwWjBAMT4wPAYDVQQDDDUwMTMxYzA1NS0xYTUyLTRkYjctODQyZi1hMGZhZTY1
Y2Y0MDIgR0VOIDEgUHJvamVjdCBDQTCCAaIwDQYJKoZIhvcNAQEBBQADggGPADCC
AYoCggGBAJKoICvm6A1XcaD+ouLn+1TM40WJOjWJ6E8nhAnzv8VFjrhlAJkPgf3x
xy52erloS4A0YT+tjCVycSAwMePk+09rKMPzdwOFtL3g0C4AqxxRPNbEGi/Aeidc
MPQ5Ry05nrzISOm/bD6usx1Wn/lHvMhS1ZIOSz0pStSWllPv3PiOViEuiHk2EJcK
OT7QGYkG4L3UEwPULL9gArIMxP+fZKliPqzzSjHx7aBhpjZhybXawYpzVfZ5yp+j
1phO50zXRfO1RmFdGX9e6bjz5YNoNX0xmo7Ka+MIyyEU0TjcogQ+O2W9SQGff7af
GSjamxJdULtR3WzwPQIc1ucLskGK10sbUzC3qqZgoZB5uty/M+TEKHsVA63BVjQ0
aPAUw1zD+6RA1Ph95YFCrKR0ROE/0MfLzhLF4wzqBTbsxvYMMU2O+WR/8yoHg6AN
ENRys1DqtGcnxZk+h24tiGDknN7OZxNdO22AiML4yI1CiiYUE2Sfyhut0Uc42me+
bl/m7VCgZwIDAQABo0IwQDAdBgNVHQ4EFgQUGJ+lgcBl0l2/mgBSlmO2DiCBcLIw
EgYDVR0TAQH/BAgwBgEB/wIBADALBgNVHQ8EBAMCAQYwDQYJKoZIhvcNAQEMBQAD
ggGBAE3N5hGtLfkFbf92d0hogWRh6MSGkX/E09z+CGIO/+PJLgFXXp5PeRbUiHJB
oaTNxfW/0HBP6v5aNaVXdGvFTH1Ft1Z+5miTQmKhMc5Ug+e1e1kbqZZam/2cs/Bh
Zcm0JgkbDOzI/rl49bpeBG+ggd4a1bST6SQlV8oHOdbk4fpwwmOgyCMpDCdOcu2y
QVaiwFhkCJLusf1KMTkBW/eghTYA6qjj9TKLmBn8Z5zwiBIifXAKDJvG1wiJttzB
9p1U85u5wWpeSie0Rw3Y/H7ysm48qOXAy33BwHXcJkjxjct6Jdeud+N1ENMHxgIu
GDfbITNrF5FS9vCZ0ugJqrt6OTXYq7AbVWV6OWYAn7vakmjUvNK7NTxtmu12Chx7
L050MAgCaoFNOjHqnOSB85OjJKSeOt9b2wgjnDEQqKco3CqhrR5kGAeYF6+s1JM5
ky/wvDyxNEAB4FItRWWNNQBmucTVwWNKE55T3fiYH12jrWGjwIVGsABLWOofCsof
qg4R+A==
-----END CERTIFICATE-----


===============================================
File: main.py
===============================================

from fastapi import FastAPI
     from fastapi.middleware.cors import CORSMiddleware
     from app.db.database import init_db

     app = FastAPI(title="LogUp Backend")

     # CORS for frontend
     app.add_middleware(
         CORSMiddleware,
         allow_origins=["http://localhost:5173"],
         allow_credentials=True,
         allow_methods=["*"],
         allow_headers=["*"],
     )

     @app.on_event("startup")
     async def startup_event():
         init_db()

     @app.get("/")
     async def root():
         return {"message": "Welcome to LogUp Backend"}

===============================================
File: requirements.txt
===============================================

[Non-text file]

===============================================
File: app\__init__.py
===============================================




===============================================
File: app\api\__init__.py
===============================================



===============================================
File: app\api\analytics.py
===============================================



===============================================
File: app\api\auth.py
===============================================



===============================================
File: app\api\budgets.py
===============================================



===============================================
File: app\api\chat.py
===============================================



===============================================
File: app\api\dashboard.py
===============================================



===============================================
File: app\api\debts.py
===============================================



===============================================
File: app\api\friends.py
===============================================



===============================================
File: app\api\goals.py
===============================================



===============================================
File: app\api\messages.py
===============================================



===============================================
File: app\api\notifications.py
===============================================



===============================================
File: app\api\permissions.py
===============================================



===============================================
File: app\api\receipts.py
===============================================



===============================================
File: app\api\savings.py
===============================================



===============================================
File: app\api\sms.py
===============================================



===============================================
File: app\api\split_expenses.py
===============================================



===============================================
File: app\api\subscriptions.py
===============================================



===============================================
File: app\api\templates.py
===============================================



===============================================
File: app\api\transactions.py
===============================================



===============================================
File: app\api\widgets.py
===============================================



===============================================
File: app\config\__init__.py
===============================================



===============================================
File: app\config\settings.py
===============================================



===============================================
File: app\db\__init__.py
===============================================



===============================================
File: app\db\database.py
===============================================

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from dotenv import load_dotenv
import os

# Load .env file
load_dotenv()

# Database configuration
DATABASE_URL = os.getenv("DATABASE_URL")
DB_POOL_SIZE = int(os.getenv("DB_POOL_SIZE", 20))
DB_MAX_OVERFLOW = int(os.getenv("DB_MAX_OVERFLOW", 10))
DB_ECHO = os.getenv("DB_ECHO", "False").lower() == "true"

# Create SQLAlchemy engine
engine = create_engine(
    DATABASE_URL,
    pool_size=DB_POOL_SIZE,
    max_overflow=DB_MAX_OVERFLOW,
    echo=DB_ECHO
)

# Create session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Base class for models
Base = declarative_base()

# Dependency for FastAPI
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Function to initialize database (create tables)
def init_db():
    Base.metadata.create_all(bind=engine)

===============================================
File: app\db\test_db_connection.py
===============================================

import os
import ssl
import asyncio
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy import text  # <-- Important!
from dotenv import load_dotenv

# Load environment variables from ../../.env
load_dotenv(dotenv_path=os.path.join(os.path.dirname(__file__), '../../.env'))

DATABASE_URL = os.getenv("DATABASE_URL")
if DATABASE_URL and not DATABASE_URL.startswith("postgresql+asyncpg"):
    DATABASE_URL = DATABASE_URL.replace("postgresql://", "postgresql+asyncpg://", 1)

def get_ssl_context():
    ca_path = os.path.join(os.path.dirname(__file__), '../../ca.pem')
    if not os.path.exists(ca_path):
        print(f"❌ CA certificate not found at {ca_path}")
        print("Please download ca.pem from your Aiven dashboard and place it in the backend directory.")
        exit(1)
    ssl_context = ssl.create_default_context(cafile=ca_path)
    return ssl_context

async def test_connection():
    print(f"Trying: {DATABASE_URL}")
    ssl_context = get_ssl_context()
    engine = create_async_engine(
        DATABASE_URL or "bad_url",
        echo=True,
        connect_args={"ssl": ssl_context}
    )
    try:
        async with engine.begin() as conn:
            # FIX: wrap SQL string in text()
            await conn.execute(text("SELECT 1;"))
        print("✅ Database connection successful!")
    except SQLAlchemyError as e:
        print("❌ Database connection failed!")
        print(repr(e))

if __name__ == "__main__":
    asyncio.run(test_connection())



===============================================
File: app\db\models\__init__.py
===============================================



===============================================
File: app\db\models\budget.py
===============================================



===============================================
File: app\db\models\debt.py
===============================================



===============================================
File: app\db\models\friend.py
===============================================



===============================================
File: app\db\models\goal.py
===============================================



===============================================
File: app\db\models\message.py
===============================================



===============================================
File: app\db\models\nudge.py
===============================================



===============================================
File: app\db\models\permission.py
===============================================



===============================================
File: app\db\models\saving.py
===============================================



===============================================
File: app\db\models\split_expense.py
===============================================



===============================================
File: app\db\models\subscription.py
===============================================



===============================================
File: app\db\models\template.py
===============================================



===============================================
File: app\db\models\transaction.py
===============================================



===============================================
File: app\db\models\user.py
===============================================



===============================================
File: app\db\models\widget_config.py
===============================================



===============================================
File: app\db\schemas\__init__.py
===============================================



===============================================
File: app\db\schemas\budget.py
===============================================



===============================================
File: app\db\schemas\debt.py
===============================================



===============================================
File: app\db\schemas\friend.py
===============================================



===============================================
File: app\db\schemas\goal.py
===============================================



===============================================
File: app\db\schemas\message.py
===============================================



===============================================
File: app\db\schemas\nudge.py
===============================================



===============================================
File: app\db\schemas\permission.py
===============================================



===============================================
File: app\db\schemas\saving.py
===============================================



===============================================
File: app\db\schemas\split_expense.py
===============================================



===============================================
File: app\db\schemas\subscription.py
===============================================



===============================================
File: app\db\schemas\template.py
===============================================



===============================================
File: app\db\schemas\transaction.py
===============================================



===============================================
File: app\db\schemas\user.py
===============================================



===============================================
File: app\db\schemas\widget_config.py
===============================================



===============================================
File: app\middleware\__init__.py
===============================================



===============================================
File: app\middleware\auth.py
===============================================



===============================================
File: app\services\__init__.py
===============================================



===============================================
File: app\services\analytics_service.py
===============================================



===============================================
File: app\services\auth_service.py
===============================================



===============================================
File: app\services\budget_service.py
===============================================



===============================================
File: app\services\chat_service.py
===============================================



===============================================
File: app\services\debt_service.py
===============================================



===============================================
File: app\services\friend_service.py
===============================================



===============================================
File: app\services\goal_service.py
===============================================



===============================================
File: app\services\message_service.py
===============================================



===============================================
File: app\services\notification_service.py
===============================================



===============================================
File: app\services\split_service.py
===============================================



===============================================
File: app\services\subscription_service.py
===============================================



===============================================
File: app\services\transaction_service.py
===============================================



===============================================
File: app\utils\__init__.py
===============================================



===============================================
File: app\utils\helpers.py
===============================================



===============================================
File: tests\__init__.py
===============================================



===============================================
File: tests\test_analytics.py
===============================================



===============================================
File: tests\test_auth.py
===============================================



===============================================
File: tests\test_budgets.py
===============================================



===============================================
File: tests\test_chat.py
===============================================



===============================================
File: tests\test_debts.py
===============================================



===============================================
File: tests\test_friends.py
===============================================



===============================================
File: tests\test_goals.py
===============================================



===============================================
File: tests\test_messages.py
===============================================



===============================================
File: tests\test_notifications.py
===============================================



===============================================
File: tests\test_receipts.py
===============================================



===============================================
File: tests\test_savings.py
===============================================



===============================================
File: tests\test_sms.py
===============================================



===============================================
File: tests\test_split_expenses.py
===============================================



===============================================
File: tests\test_subscriptions.py
===============================================



===============================================
File: tests\test_templates.py
===============================================



===============================================
File: tests\test_transactions.py
===============================================




===============================================
File: IngestBackend 2.txt
===============================================

Ingestion Results for e:\LogUp\backend
Summary
Directory: backend
Files analyzed: 96

Estimated tokens: 25.2k


Directory structure:
└── backend/
    ├── README.md
    ├── ca.pem
    ├── IngestBackend 1.txt
    ├── main.py
    ├── requirements.txt
    ├── app/
    │   ├── __init__.py
    │   ├── __pycache__/
    │   ├── api/
    │   │   ├── __init__.py
    │   │   ├── analytics.py
    │   │   ├── auth.py
    │   │   ├── budgets.py
    │   │   ├── chat.py
    │   │   ├── dashboard.py
    │   │   ├── debts.py
    │   │   ├── friends.py
    │   │   ├── goals.py
    │   │   ├── messages.py
    │   │   ├── notifications.py
    │   │   ├── permissions.py
    │   │   ├── receipts.py
    │   │   ├── savings.py
    │   │   ├── sms.py
    │   │   ├── split_expenses.py
    │   │   ├── subscriptions.py
    │   │   ├── templates.py
    │   │   ├── transactions.py
    │   │   ├── widgets.py
    │   │   └── __pycache__/
    │   ├── config/
    │   │   ├── __init__.py
    │   │   └── settings.py
    │   ├── db/
    │   │   ├── __init__.py
    │   │   ├── create_tables.py
    │   │   ├── database.py
    │   │   ├── test_db_connection.py
    │   │   ├── __pycache__/
    │   │   ├── models/
    │   │   │   ├── __init__.py
    │   │   │   ├── budget.py
    │   │   │   ├── debt.py
    │   │   │   ├── friend.py
    │   │   │   ├── goal.py
    │   │   │   ├── message.py
    │   │   │   ├── nudge.py
    │   │   │   ├── permission.py
    │   │   │   ├── saving.py
    │   │   │   ├── split_expense.py
    │   │   │   ├── subscription.py
    │   │   │   ├── template.py
    │   │   │   ├── transaction.py
    │   │   │   ├── user.py
    │   │   │   ├── widget_config.py
    │   │   │   └── __pycache__/
    │   │   └── schemas/
    │   │       ├── __init__.py
    │   │       ├── budget.py
    │   │       ├── debt.py
    │   │       ├── friend.py
    │   │       ├── goal.py
    │   │       ├── message.py
    │   │       ├── nudge.py
    │   │       ├── permission.py
    │   │       ├── saving.py
    │   │       ├── split_expense.py
    │   │       ├── subscription.py
    │   │       ├── template.py
    │   │       ├── transaction.py
    │   │       ├── user.py
    │   │       ├── widget_config.py
    │   │       └── __pycache__/
    │   ├── middleware/
    │   │   ├── __init__.py
    │   │   └── auth.py
    │   ├── services/
    │   │   ├── __init__.py
    │   │   ├── analytics_service.py
    │   │   ├── auth_service.py
    │   │   ├── budget_service.py
    │   │   ├── chat_service.py
    │   │   ├── debt_service.py
    │   │   ├── friend_service.py
    │   │   ├── goal_service.py
    │   │   ├── message_service.py
    │   │   ├── notification_service.py
    │   │   ├── split_service.py
    │   │   ├── subscription_service.py
    │   │   └── transaction_service.py
    │   └── utils/
    │       ├── __init__.py
    │       └── helpers.py
    └── tests/
        ├── __init__.py
        ├── test_analytics.py
        ├── test_auth.py
        ├── test_budgets.py
        ├── test_chat.py
        ├── test_debts.py
        ├── test_friends.py
        ├── test_goals.py
        ├── test_messages.py
        ├── test_notifications.py
        ├── test_receipts.py
        ├── test_savings.py
        ├── test_sms.py
        ├── test_split_expenses.py
        ├── test_subscriptions.py
        ├── test_templates.py
        ├── test_transactions.py
        └── __pycache__/


File Contents

===============================================
File: README.md
===============================================



===============================================
File: ca.pem
===============================================

-----BEGIN CERTIFICATE-----
MIIEUDCCArigAwIBAgIUCO+u/6m7BQ+0IK13DE3KPKxxUVYwDQYJKoZIhvcNAQEM
BQAwQDE+MDwGA1UEAww1MDEzMWMwNTUtMWE1Mi00ZGI3LTg0MmYtYTBmYWU2NWNm
NDAyIEdFTiAxIFByb2plY3QgQ0EwHhcNMjUwNzMwMTAxMTEwWhcNMzUwNzI4MTAx
MTEwWjBAMT4wPAYDVQQDDDUwMTMxYzA1NS0xYTUyLTRkYjctODQyZi1hMGZhZTY1
Y2Y0MDIgR0VOIDEgUHJvamVjdCBDQTCCAaIwDQYJKoZIhvcNAQEBBQADggGPADCC
AYoCggGBAJKoICvm6A1XcaD+ouLn+1TM40WJOjWJ6E8nhAnzv8VFjrhlAJkPgf3x
xy52erloS4A0YT+tjCVycSAwMePk+09rKMPzdwOFtL3g0C4AqxxRPNbEGi/Aeidc
MPQ5Ry05nrzISOm/bD6usx1Wn/lHvMhS1ZIOSz0pStSWllPv3PiOViEuiHk2EJcK
OT7QGYkG4L3UEwPULL9gArIMxP+fZKliPqzzSjHx7aBhpjZhybXawYpzVfZ5yp+j
1phO50zXRfO1RmFdGX9e6bjz5YNoNX0xmo7Ka+MIyyEU0TjcogQ+O2W9SQGff7af
GSjamxJdULtR3WzwPQIc1ucLskGK10sbUzC3qqZgoZB5uty/M+TEKHsVA63BVjQ0
aPAUw1zD+6RA1Ph95YFCrKR0ROE/0MfLzhLF4wzqBTbsxvYMMU2O+WR/8yoHg6AN
ENRys1DqtGcnxZk+h24tiGDknN7OZxNdO22AiML4yI1CiiYUE2Sfyhut0Uc42me+
bl/m7VCgZwIDAQABo0IwQDAdBgNVHQ4EFgQUGJ+lgcBl0l2/mgBSlmO2DiCBcLIw
EgYDVR0TAQH/BAgwBgEB/wIBADALBgNVHQ8EBAMCAQYwDQYJKoZIhvcNAQEMBQAD
ggGBAE3N5hGtLfkFbf92d0hogWRh6MSGkX/E09z+CGIO/+PJLgFXXp5PeRbUiHJB
oaTNxfW/0HBP6v5aNaVXdGvFTH1Ft1Z+5miTQmKhMc5Ug+e1e1kbqZZam/2cs/Bh
Zcm0JgkbDOzI/rl49bpeBG+ggd4a1bST6SQlV8oHOdbk4fpwwmOgyCMpDCdOcu2y
QVaiwFhkCJLusf1KMTkBW/eghTYA6qjj9TKLmBn8Z5zwiBIifXAKDJvG1wiJttzB
9p1U85u5wWpeSie0Rw3Y/H7ysm48qOXAy33BwHXcJkjxjct6Jdeud+N1ENMHxgIu
GDfbITNrF5FS9vCZ0ugJqrt6OTXYq7AbVWV6OWYAn7vakmjUvNK7NTxtmu12Chx7
L050MAgCaoFNOjHqnOSB85OjJKSeOt9b2wgjnDEQqKco3CqhrR5kGAeYF6+s1JM5
ky/wvDyxNEAB4FItRWWNNQBmucTVwWNKE55T3fiYH12jrWGjwIVGsABLWOofCsof
qg4R+A==
-----END CERTIFICATE-----


===============================================
File: IngestBackend 1.txt
===============================================

Ingestion Results for e:\LogUp\backend
Summary
Directory: backend
Files analyzed: 94

Estimated tokens: 5.0k


Directory structure:
└── backend/
    ├── README.md
    ├── ca.pem
    ├── main.py
    ├── requirements.txt
    ├── app/
    │   ├── __init__.py
    │   ├── __pycache__/
    │   ├── api/
    │   │   ├── __init__.py
    │   │   ├── analytics.py
    │   │   ├── auth.py
    │   │   ├── budgets.py
    │   │   ├── chat.py
    │   │   ├── dashboard.py
    │   │   ├── debts.py
    │   │   ├── friends.py
    │   │   ├── goals.py
    │   │   ├── messages.py
    │   │   ├── notifications.py
    │   │   ├── permissions.py
    │   │   ├── receipts.py
    │   │   ├── savings.py
    │   │   ├── sms.py
    │   │   ├── split_expenses.py
    │   │   ├── subscriptions.py
    │   │   ├── templates.py
    │   │   ├── transactions.py
    │   │   └── widgets.py
    │   ├── config/
    │   │   ├── __init__.py
    │   │   └── settings.py
    │   ├── db/
    │   │   ├── __init__.py
    │   │   ├── database.py
    │   │   ├── test_db_connection.py
    │   │   ├── __pycache__/
    │   │   ├── models/
    │   │   │   ├── __init__.py
    │   │   │   ├── budget.py
    │   │   │   ├── debt.py
    │   │   │   ├── friend.py
    │   │   │   ├── goal.py
    │   │   │   ├── message.py
    │   │   │   ├── nudge.py
    │   │   │   ├── permission.py
    │   │   │   ├── saving.py
    │   │   │   ├── split_expense.py
    │   │   │   ├── subscription.py
    │   │   │   ├── template.py
    │   │   │   ├── transaction.py
    │   │   │   ├── user.py
    │   │   │   └── widget_config.py
    │   │   └── schemas/
    │   │       ├── __init__.py
    │   │       ├── budget.py
    │   │       ├── debt.py
    │   │       ├── friend.py
    │   │       ├── goal.py
    │   │       ├── message.py
    │   │       ├── nudge.py
    │   │       ├── permission.py
    │   │       ├── saving.py
    │   │       ├── split_expense.py
    │   │       ├── subscription.py
    │   │       ├── template.py
    │   │       ├── transaction.py
    │   │       ├── user.py
    │   │       └── widget_config.py
    │   ├── middleware/
    │   │   ├── __init__.py
    │   │   └── auth.py
    │   ├── services/
    │   │   ├── __init__.py
    │   │   ├── analytics_service.py
    │   │   ├── auth_service.py
    │   │   ├── budget_service.py
    │   │   ├── chat_service.py
    │   │   ├── debt_service.py
    │   │   ├── friend_service.py
    │   │   ├── goal_service.py
    │   │   ├── message_service.py
    │   │   ├── notification_service.py
    │   │   ├── split_service.py
    │   │   ├── subscription_service.py
    │   │   └── transaction_service.py
    │   └── utils/
    │       ├── __init__.py
    │       └── helpers.py
    └── tests/
        ├── __init__.py
        ├── test_analytics.py
        ├── test_auth.py
        ├── test_budgets.py
        ├── test_chat.py
        ├── test_debts.py
        ├── test_friends.py
        ├── test_goals.py
        ├── test_messages.py
        ├── test_notifications.py
        ├── test_receipts.py
        ├── test_savings.py
        ├── test_sms.py
        ├── test_split_expenses.py
        ├── test_subscriptions.py
        ├── test_templates.py
        └── test_transactions.py


File Contents

===============================================
File: README.md
===============================================



===============================================
File: ca.pem
===============================================

-----BEGIN CERTIFICATE-----
MIIEUDCCArigAwIBAgIUCO+u/6m7BQ+0IK13DE3KPKxxUVYwDQYJKoZIhvcNAQEM
BQAwQDE+MDwGA1UEAww1MDEzMWMwNTUtMWE1Mi00ZGI3LTg0MmYtYTBmYWU2NWNm
NDAyIEdFTiAxIFByb2plY3QgQ0EwHhcNMjUwNzMwMTAxMTEwWhcNMzUwNzI4MTAx
MTEwWjBAMT4wPAYDVQQDDDUwMTMxYzA1NS0xYTUyLTRkYjctODQyZi1hMGZhZTY1
Y2Y0MDIgR0VOIDEgUHJvamVjdCBDQTCCAaIwDQYJKoZIhvcNAQEBBQADggGPADCC
AYoCggGBAJKoICvm6A1XcaD+ouLn+1TM40WJOjWJ6E8nhAnzv8VFjrhlAJkPgf3x
xy52erloS4A0YT+tjCVycSAwMePk+09rKMPzdwOFtL3g0C4AqxxRPNbEGi/Aeidc
MPQ5Ry05nrzISOm/bD6usx1Wn/lHvMhS1ZIOSz0pStSWllPv3PiOViEuiHk2EJcK
OT7QGYkG4L3UEwPULL9gArIMxP+fZKliPqzzSjHx7aBhpjZhybXawYpzVfZ5yp+j
1phO50zXRfO1RmFdGX9e6bjz5YNoNX0xmo7Ka+MIyyEU0TjcogQ+O2W9SQGff7af
GSjamxJdULtR3WzwPQIc1ucLskGK10sbUzC3qqZgoZB5uty/M+TEKHsVA63BVjQ0
aPAUw1zD+6RA1Ph95YFCrKR0ROE/0MfLzhLF4wzqBTbsxvYMMU2O+WR/8yoHg6AN
ENRys1DqtGcnxZk+h24tiGDknN7OZxNdO22AiML4yI1CiiYUE2Sfyhut0Uc42me+
bl/m7VCgZwIDAQABo0IwQDAdBgNVHQ4EFgQUGJ+lgcBl0l2/mgBSlmO2DiCBcLIw
EgYDVR0TAQH/BAgwBgEB/wIBADALBgNVHQ8EBAMCAQYwDQYJKoZIhvcNAQEMBQAD
ggGBAE3N5hGtLfkFbf92d0hogWRh6MSGkX/E09z+CGIO/+PJLgFXXp5PeRbUiHJB
oaTNxfW/0HBP6v5aNaVXdGvFTH1Ft1Z+5miTQmKhMc5Ug+e1e1kbqZZam/2cs/Bh
Zcm0JgkbDOzI/rl49bpeBG+ggd4a1bST6SQlV8oHOdbk4fpwwmOgyCMpDCdOcu2y
QVaiwFhkCJLusf1KMTkBW/eghTYA6qjj9TKLmBn8Z5zwiBIifXAKDJvG1wiJttzB
9p1U85u5wWpeSie0Rw3Y/H7ysm48qOXAy33BwHXcJkjxjct6Jdeud+N1ENMHxgIu
GDfbITNrF5FS9vCZ0ugJqrt6OTXYq7AbVWV6OWYAn7vakmjUvNK7NTxtmu12Chx7
L050MAgCaoFNOjHqnOSB85OjJKSeOt9b2wgjnDEQqKco3CqhrR5kGAeYF6+s1JM5
ky/wvDyxNEAB4FItRWWNNQBmucTVwWNKE55T3fiYH12jrWGjwIVGsABLWOofCsof
qg4R+A==
-----END CERTIFICATE-----


===============================================
File: main.py
===============================================

from fastapi import FastAPI
     from fastapi.middleware.cors import CORSMiddleware
     from app.db.database import init_db

     app = FastAPI(title="LogUp Backend")

     # CORS for frontend
     app.add_middleware(
         CORSMiddleware,
         allow_origins=["http://localhost:5173"],
         allow_credentials=True,
         allow_methods=["*"],
         allow_headers=["*"],
     )

     @app.on_event("startup")
     async def startup_event():
         init_db()

     @app.get("/")
     async def root():
         return {"message": "Welcome to LogUp Backend"}

===============================================
File: requirements.txt
===============================================

[Non-text file]

===============================================
File: app\__init__.py
===============================================




===============================================
File: app\api\__init__.py
===============================================



===============================================
File: app\api\analytics.py
===============================================



===============================================
File: app\api\auth.py
===============================================



===============================================
File: app\api\budgets.py
===============================================



===============================================
File: app\api\chat.py
===============================================



===============================================
File: app\api\dashboard.py
===============================================



===============================================
File: app\api\debts.py
===============================================



===============================================
File: app\api\friends.py
===============================================



===============================================
File: app\api\goals.py
===============================================



===============================================
File: app\api\messages.py
===============================================



===============================================
File: app\api\notifications.py
===============================================



===============================================
File: app\api\permissions.py
===============================================



===============================================
File: app\api\receipts.py
===============================================



===============================================
File: app\api\savings.py
===============================================



===============================================
File: app\api\sms.py
===============================================



===============================================
File: app\api\split_expenses.py
===============================================



===============================================
File: app\api\subscriptions.py
===============================================



===============================================
File: app\api\templates.py
===============================================



===============================================
File: app\api\transactions.py
===============================================



===============================================
File: app\api\widgets.py
===============================================



===============================================
File: app\config\__init__.py
===============================================



===============================================
File: app\config\settings.py
===============================================



===============================================
File: app\db\__init__.py
===============================================



===============================================
File: app\db\database.py
===============================================

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from dotenv import load_dotenv
import os

# Load .env file
load_dotenv()

# Database configuration
DATABASE_URL = os.getenv("DATABASE_URL")
DB_POOL_SIZE = int(os.getenv("DB_POOL_SIZE", 20))
DB_MAX_OVERFLOW = int(os.getenv("DB_MAX_OVERFLOW", 10))
DB_ECHO = os.getenv("DB_ECHO", "False").lower() == "true"

# Create SQLAlchemy engine
engine = create_engine(
    DATABASE_URL,
    pool_size=DB_POOL_SIZE,
    max_overflow=DB_MAX_OVERFLOW,
    echo=DB_ECHO
)

# Create session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Base class for models
Base = declarative_base()

# Dependency for FastAPI
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Function to initialize database (create tables)
def init_db():
    Base.metadata.create_all(bind=engine)

===============================================
File: app\db\test_db_connection.py
===============================================

import os
import ssl
import asyncio
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy import text  # <-- Important!
from dotenv import load_dotenv

# Load environment variables from ../../.env
load_dotenv(dotenv_path=os.path.join(os.path.dirname(__file__), '../../.env'))

DATABASE_URL = os.getenv("DATABASE_URL")
if DATABASE_URL and not DATABASE_URL.startswith("postgresql+asyncpg"):
    DATABASE_URL = DATABASE_URL.replace("postgresql://", "postgresql+asyncpg://", 1)

def get_ssl_context():
    ca_path = os.path.join(os.path.dirname(__file__), '../../ca.pem')
    if not os.path.exists(ca_path):
        print(f"❌ CA certificate not found at {ca_path}")
        print("Please download ca.pem from your Aiven dashboard and place it in the backend directory.")
        exit(1)
    ssl_context = ssl.create_default_context(cafile=ca_path)
    return ssl_context

async def test_connection():
    print(f"Trying: {DATABASE_URL}")
    ssl_context = get_ssl_context()
    engine = create_async_engine(
        DATABASE_URL or "bad_url",
        echo=True,
        connect_args={"ssl": ssl_context}
    )
    try:
        async with engine.begin() as conn:
            # FIX: wrap SQL string in text()
            await conn.execute(text("SELECT 1;"))
        print("✅ Database connection successful!")
    except SQLAlchemyError as e:
        print("❌ Database connection failed!")
        print(repr(e))

if __name__ == "__main__":
    asyncio.run(test_connection())



===============================================
File: app\db\models\__init__.py
===============================================



===============================================
File: app\db\models\budget.py
===============================================



===============================================
File: app\db\models\debt.py
===============================================



===============================================
File: app\db\models\friend.py
===============================================



===============================================
File: app\db\models\goal.py
===============================================



===============================================
File: app\db\models\message.py
===============================================



===============================================
File: app\db\models\nudge.py
===============================================



===============================================
File: app\db\models\permission.py
===============================================



===============================================
File: app\db\models\saving.py
===============================================



===============================================
File: app\db\models\split_expense.py
===============================================



===============================================
File: app\db\models\subscription.py
===============================================



===============================================
File: app\db\models\template.py
===============================================



===============================================
File: app\db\models\transaction.py
===============================================



===============================================
File: app\db\models\user.py
===============================================



===============================================
File: app\db\models\widget_config.py
===============================================



===============================================
File: app\db\schemas\__init__.py
===============================================



===============================================
File: app\db\schemas\budget.py
===============================================



===============================================
File: app\db\schemas\debt.py
===============================================



===============================================
File: app\db\schemas\friend.py
===============================================



===============================================
File: app\db\schemas\goal.py
===============================================



===============================================
File: app\db\schemas\message.py
===============================================



===============================================
File: app\db\schemas\nudge.py
===============================================



===============================================
File: app\db\schemas\permission.py
===============================================



===============================================
File: app\db\schemas\saving.py
===============================================



===============================================
File: app\db\schemas\split_expense.py
===============================================



===============================================
File: app\db\schemas\subscription.py
===============================================



===============================================
File: app\db\schemas\template.py
===============================================



===============================================
File: app\db\schemas\transaction.py
===============================================



===============================================
File: app\db\schemas\user.py
===============================================



===============================================
File: app\db\schemas\widget_config.py
===============================================



===============================================
File: app\middleware\__init__.py
===============================================



===============================================
File: app\middleware\auth.py
===============================================



===============================================
File: app\services\__init__.py
===============================================



===============================================
File: app\services\analytics_service.py
===============================================



===============================================
File: app\services\auth_service.py
===============================================



===============================================
File: app\services\budget_service.py
===============================================



===============================================
File: app\services\chat_service.py
===============================================



===============================================
File: app\services\debt_service.py
===============================================



===============================================
File: app\services\friend_service.py
===============================================



===============================================
File: app\services\goal_service.py
===============================================



===============================================
File: app\services\message_service.py
===============================================



===============================================
File: app\services\notification_service.py
===============================================



===============================================
File: app\services\split_service.py
===============================================



===============================================
File: app\services\subscription_service.py
===============================================



===============================================
File: app\services\transaction_service.py
===============================================



===============================================
File: app\utils\__init__.py
===============================================



===============================================
File: app\utils\helpers.py
===============================================



===============================================
File: tests\__init__.py
===============================================



===============================================
File: tests\test_analytics.py
===============================================



===============================================
File: tests\test_auth.py
===============================================



===============================================
File: tests\test_budgets.py
===============================================



===============================================
File: tests\test_chat.py
===============================================



===============================================
File: tests\test_debts.py
===============================================



===============================================
File: tests\test_friends.py
===============================================



===============================================
File: tests\test_goals.py
===============================================



===============================================
File: tests\test_messages.py
===============================================



===============================================
File: tests\test_notifications.py
===============================================



===============================================
File: tests\test_receipts.py
===============================================



===============================================
File: tests\test_savings.py
===============================================



===============================================
File: tests\test_sms.py
===============================================



===============================================
File: tests\test_split_expenses.py
===============================================



===============================================
File: tests\test_subscriptions.py
===============================================



===============================================
File: tests\test_templates.py
===============================================



===============================================
File: tests\test_transactions.py
===============================================




===============================================
File: main.py
===============================================

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.db.database import init_db
from app.api.auth import router as auth_router
from app.api.transactions import router as transactions_router
from app.api.debts import router as debts_router
from app.api.split_expenses import router as split_expenses_router
from app.api.subscriptions import router as subscriptions_router
from app.api.budgets import router as budgets_router
from app.api.goals import router as goals_router
from app.api.savings import router as savings_router
from app.api.friends import router as friends_router
from app.api.messages import router as messages_router
from app.api.notifications import router as notifications_router
from app.api.permissions import router as permissions_router
from app.api.templates import router as templates_router
from app.api.widgets import router as widgets_router
from app.api.analytics import router as analytics_router
from app.api.dashboard import router as dashboard_router
from app.api.chat import router as chat_router
from app.api.receipts import router as receipts_router
from app.api.sms import router as sms_router

app = FastAPI(title="LogUp Backend")

# CORS for frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include all API routers
app.include_router(auth_router)
app.include_router(transactions_router)
app.include_router(debts_router)
app.include_router(split_expenses_router)
app.include_router(subscriptions_router)
app.include_router(budgets_router)
app.include_router(goals_router)
app.include_router(savings_router)
app.include_router(friends_router)
app.include_router(messages_router)
app.include_router(notifications_router)
app.include_router(permissions_router)
app.include_router(templates_router)
app.include_router(widgets_router)
app.include_router(analytics_router)
app.include_router(dashboard_router)
app.include_router(chat_router)
app.include_router(receipts_router)
app.include_router(sms_router)

@app.on_event("startup")
async def startup_event():
    init_db()

@app.get("/")
async def root():
    return {"message": "Welcome to LogUp Backend"}

===============================================
File: requirements.txt
===============================================

[Non-text file]

===============================================
File: app\__init__.py
===============================================




===============================================
File: app\api\__init__.py
===============================================

from .auth import router as auth_router
from .transactions import router as transactions_router
from .debts import router as debts_router
from .split_expenses import router as split_expenses_router
from .subscriptions import router as subscriptions_router
from .budgets import router as budgets_router
from .goals import router as goals_router
from .savings import router as savings_router
from .friends import router as friends_router
from .messages import router as messages_router
from .notifications import router as notifications_router
from .permissions import router as permissions_router
from .templates import router as templates_router
from .widgets import router as widgets_router
from .analytics import router as analytics_router
from .dashboard import router as dashboard_router
from .chat import router as chat_router
from .receipts import router as receipts_router
from .sms import router as sms_router

===============================================
File: app\api\analytics.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.db.database import get_db
from typing import Dict

router = APIRouter(prefix="/analytics", tags=["analytics"])

@router.get("/summary", response_model=Dict)
async def get_analytics_summary(user_id: int, db: Session = Depends(get_db)):
    # Placeholder for analytics summary (e.g., total expenses, savings, debts)
    return {
        "user_id": user_id,
        "total_expenses": 0.0,
        "total_savings": 0.0,
        "total_debts": 0.0
    }

===============================================
File: app\api\auth.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.db.database import get_db
from app.db.models.user import User
from app.db.schemas.user import UserCreate, User as UserSchema
from passlib.context import CryptContext

router = APIRouter(prefix="/auth", tags=["auth"])

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

@router.post("/signup", response_model=UserSchema, status_code=status.HTTP_201_CREATED)
async def signup(user: UserCreate, db: Session = Depends(get_db)):
    existing_user = db.query(User).filter(User.email == user.email).first()
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )
    
    hashed_password = pwd_context.hash(user.password)
    db_user = User(
        username=user.username,
        email=user.email,
        password_hash=hashed_password,
        phone_number=user.phone_number
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

@router.post("/login")
async def login(user: UserCreate, db: Session = Depends(get_db)):
    db_user = db.query(User).filter(User.email == user.email).first()
    if not db_user or not pwd_context.verify(user.password, db_user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password"
        )
    return {"message": "Login successful", "user_id": db_user.id}

===============================================
File: app\api\budgets.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.budget import Budget
from app.db.schemas.budget import BudgetCreate, Budget

router = APIRouter(prefix="/budgets", tags=["budgets"])

@router.post("/", response_model=Budget, status_code=status.HTTP_201_CREATED)
async def create_budget(budget: BudgetCreate, user_id: int, db: Session = Depends(get_db)):
    db_budget = Budget(**budget.dict(), user_id=user_id)
    db.add(db_budget)
    db.commit()
    db.refresh(db_budget)
    return db_budget

@router.get("/{budget_id}", response_model=Budget)
async def get_budget(budget_id: int, user_id: int, db: Session = Depends(get_db)):
    budget = db.query(Budget).filter(Budget.id == budget_id, Budget.user_id == user_id).first()
    if not budget:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Budget not found")
    return budget

@router.get("/", response_model=List[Budget])
async def get_budgets(user_id: int, db: Session = Depends(get_db)):
    budgets = db.query(Budget).filter(Budget.user_id == user_id).all()
    return budgets

@router.put("/{budget_id}", response_model=Budget)
async def update_budget(budget_id: int, budget: BudgetCreate, user_id: int, db: Session = Depends(get_db)):
    db_budget = db.query(Budget).filter(Budget.id == budget_id, Budget.user_id == user_id).first()
    if not db_budget:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Budget not found")
    for key, value in budget.dict().items():
        setattr(db_budget, key, value)
    db.commit()
    db.refresh(db_budget)
    return db_budget

@router.delete("/{budget_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_budget(budget_id: int, user_id: int, db: Session = Depends(get_db)):
    db_budget = db.query(Budget).filter(Budget.id == budget_id, Budget.user_id == user_id).first()
    if not db_budget:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Budget not found")
    db.delete(db_budget)
    db.commit()

===============================================
File: app\api\chat.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.db.database import get_db
from typing import Dict

router = APIRouter(prefix="/chat", tags=["chat"])

@router.post("/message", response_model=Dict)
async def send_chat_message(message: Dict, user_id: int, db: Session = Depends(get_db)):
    # Placeholder for AI chat processing (to be integrated with Qdrant later)
    return {
        "user_id": user_id,
        "message": message.get("content"),
        "response": "AI response placeholder"
    }

===============================================
File: app\api\dashboard.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.db.database import get_db
from typing import Dict

router = APIRouter(prefix="/analytics", tags=["analytics"])

@router.get("/summary", response_model=Dict)
async def get_analytics_summary(user_id: int, db: Session = Depends(get_db)):
    # Placeholder for analytics summary (e.g., total expenses, savings, debts)
    return {
        "user_id": user_id,
        "total_expenses": 0.0,
        "total_savings": 0.0,
        "total_debts": 0.0
    }

===============================================
File: app\api\debts.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.debt import Debt
from app.db.schemas.debt import DebtCreate, Debt

router = APIRouter(prefix="/debts", tags=["debts"])

@router.post("/", response_model=Debt, status_code=status.HTTP_201_CREATED)
async def create_debt(debt: DebtCreate, user_id: int, db: Session = Depends(get_db)):
    db_debt = Debt(**debt.dict(), user_id=user_id)
    db.add(db_debt)
    db.commit()
    db.refresh(db_debt)
    return db_debt

@router.get("/{debt_id}", response_model=Debt)
async def get_debt(debt_id: int, user_id: int, db: Session = Depends(get_db)):
    debt = db.query(Debt).filter(Debt.id == debt_id, Debt.user_id == user_id).first()
    if not debt:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Debt not found")
    return debt

@router.get("/", response_model=List[Debt])
async def get_debts(user_id: int, db: Session = Depends(get_db)):
    debts = db.query(Debt).filter(Debt.user_id == user_id).all()
    return debts

@router.put("/{debt_id}", response_model=Debt)
async def update_debt(debt_id: int, debt: DebtCreate, user_id: int, db: Session = Depends(get_db)):
    db_debt = db.query(Debt).filter(Debt.id == debt_id, Debt.user_id == user_id).first()
    if not db_debt:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Debt not found")
    for key, value in debt.dict().items():
        setattr(db_debt, key, value)
    db.commit()
    db.refresh(db_debt)
    return db_debt

@router.delete("/{debt_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_debt(debt_id: int, user_id: int, db: Session = Depends(get_db)):
    db_debt = db.query(Debt).filter(Debt.id == debt_id, Debt.user_id == user_id).first()
    if not db_debt:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Debt not found")
    db.delete(db_debt)
    db.commit()

===============================================
File: app\api\friends.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.friend import Friend
from app.db.schemas.friend import FriendCreate, Friend

router = APIRouter(prefix="/friends", tags=["friends"])

@router.post("/", response_model=Friend, status_code=status.HTTP_201_CREATED)
async def create_friend(friend: FriendCreate, user_id: int, db: Session = Depends(get_db)):
    db_friend = Friend(**friend.dict(), user_id=user_id)
    db.add(db_friend)
    db.commit()
    db.refresh(db_friend)
    return db_friend

@router.get("/{friend_id}", response_model=Friend)
async def get_friend(friend_id: int, user_id: int, db: Session = Depends(get_db)):
    friend = db.query(Friend).filter(Friend.id == friend_id, Friend.user_id == user_id).first()
    if not friend:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Friend not found")
    return friend

@router.get("/", response_model=List[Friend])
async def get_friends(user_id: int, db: Session = Depends(get_db)):
    friends = db.query(Friend).filter(Friend.user_id == user_id).all()
    return friends

@router.put("/{friend_id}", response_model=Friend)
async def update_friend(friend_id: int, friend: FriendCreate, user_id: int, db: Session = Depends(get_db)):
    db_friend = db.query(Friend).filter(Friend.id == friend_id, Friend.user_id == user_id).first()
    if not db_friend:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Friend not found")
    for key, value in friend.dict().items():
        setattr(db_friend, key, value)
    db.commit()
    db.refresh(db_friend)
    return db_friend

@router.delete("/{friend_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_friend(friend_id: int, user_id: int, db: Session = Depends(get_db)):
    db_friend = db.query(Friend).filter(Friend.id == friend_id, Friend.user_id == user_id).first()
    if not db_friend:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Friend not found")
    db.delete(db_friend)
    db.commit()

===============================================
File: app\api\goals.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.goal import Goal
from app.db.schemas.goal import GoalCreate, Goal

router = APIRouter(prefix="/goals", tags=["goals"])

@router.post("/", response_model=Goal, status_code=status.HTTP_201_CREATED)
async def create_goal(goal: GoalCreate, user_id: int, db: Session = Depends(get_db)):
    db_goal = Goal(**goal.dict(), user_id=user_id)
    db.add(db_goal)
    db.commit()
    db.refresh(db_goal)
    return db_goal

@router.get("/{goal_id}", response_model=Goal)
async def get_goal(goal_id: int, user_id: int, db: Session = Depends(get_db)):
    goal = db.query(Goal).filter(Goal.id == goal_id, Goal.user_id == user_id).first()
    if not goal:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Goal not found")
    return goal

@router.get("/", response_model=List[Goal])
async def get_goals(user_id: int, db: Session = Depends(get_db)):
    goals = db.query(Goal).filter(Goal.user_id == user_id).all()
    return goals

@router.put("/{goal_id}", response_model=Goal)
async def update_goal(goal_id: int, goal: GoalCreate, user_id: int, db: Session = Depends(get_db)):
    db_goal = db.query(Goal).filter(Goal.id == goal_id, Goal.user_id == user_id).first()
    if not db_goal:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Goal not found")
    for key, value in goal.dict().items():
        setattr(db_goal, key, value)
    db.commit()
    db.refresh(db_goal)
    return db_goal

@router.delete("/{goal_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_goal(goal_id: int, user_id: int, db: Session = Depends(get_db)):
    db_goal = db.query(Goal).filter(Goal.id == goal_id, Goal.user_id == user_id).first()
    if not db_goal:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Goal not found")
    db.delete(db_goal)
    db.commit()

===============================================
File: app\api\messages.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.message import Message
from app.db.schemas.message import MessageCreate, Message

router = APIRouter(prefix="/messages", tags=["messages"])

@router.post("/", response_model=Message, status_code=status.HTTP_201_CREATED)
async def create_message(message: MessageCreate, user_id: int, db: Session = Depends(get_db)):
    db_message = Message(**message.dict(), user_id=user_id)
    db.add(db_message)
    db.commit()
    db.refresh(db_message)
    return db_message

@router.get("/{message_id}", response_model=Message)
async def get_message(message_id: int, user_id: int, db: Session = Depends(get_db)):
    message = db.query(Message).filter(Message.id == message_id, Message.user_id == user_id).first()
    if not message:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Message not found")
    return message

@router.get("/", response_model=List[Message])
async def get_messages(user_id: int, db: Session = Depends(get_db)):
    messages = db.query(Message).filter(Message.user_id == user_id).all()
    return messages

@router.delete("/{message_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_message(message_id: int, user_id: int, db: Session = Depends(get_db)):
    db_message = db.query(Message).filter(Message.id == message_id, Message.user_id == user_id).first()
    if not db_message:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Message not found")
    db.delete(db_message)
    db.commit()

===============================================
File: app\api\notifications.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.nudge import Nudge
from app.db.schemas.nudge import NudgeCreate, Nudge

router = APIRouter(prefix="/notifications", tags=["notifications"])

@router.post("/", response_model=Nudge, status_code=status.HTTP_201_CREATED)
async def create_notification(nudge: NudgeCreate, user_id: int, db: Session = Depends(get_db)):
    db_nudge = Nudge(**nudge.dict(), user_id=user_id)
    db.add(db_nudge)
    db.commit()
    db.refresh(db_nudge)
    return db_nudge

@router.get("/{nudge_id}", response_model=Nudge)
async def get_notification(nudge_id: int, user_id: int, db: Session = Depends(get_db)):
    nudge = db.query(Nudge).filter(Nudge.id == nudge_id, Nudge.user_id == user_id).first()
    if not nudge:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Notification not found")
    return nudge

@router.get("/", response_model=List[Nudge])
async def get_notifications(user_id: int, db: Session = Depends(get_db)):
    nudges = db.query(Nudge).filter(Nudge.user_id == user_id).all()
    return nudges

@router.put("/{nudge_id}", response_model=Nudge)
async def update_notification(nudge_id: int, nudge: NudgeCreate, user_id: int, db: Session = Depends(get_db)):
    db_nudge = db.query(Nudge).filter(Nudge.id == nudge_id, Nudge.user_id == user_id).first()
    if not db_nudge:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Notification not found")
    for key, value in nudge.dict().items():
        setattr(db_nudge, key, value)
    db.commit()
    db.refresh(db_nudge)
    return db_nudge

@router.delete("/{nudge_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_notification(nudge_id: int, user_id: int, db: Session = Depends(get_db)):
    db_nudge = db.query(Nudge).filter(Nudge.id == nudge_id, Nudge.user_id == user_id).first()
    if not db_nudge:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Notification not found")
    db.delete(db_nudge)
    db.commit()

===============================================
File: app\api\permissions.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.permission import Permission
from app.db.schemas.permission import PermissionCreate, Permission

router = APIRouter(prefix="/permissions", tags=["permissions"])

@router.post("/", response_model=Permission, status_code=status.HTTP_201_CREATED)
async def create_permission(permission: PermissionCreate, user_id: int, db: Session = Depends(get_db)):
    db_permission = Permission(**permission.dict(), user_id=user_id)
    db.add(db_permission)
    db.commit()
    db.refresh(db_permission)
    return db_permission

@router.get("/{permission_id}", response_model=Permission)
async def get_permission(permission_id: int, user_id: int, db: Session = Depends(get_db)):
    permission = db.query(Permission).filter(Permission.id == permission_id, Permission.user_id == user_id).first()
    if not permission:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Permission not found")
    return permission

@router.get("/", response_model=List[Permission])
async def get_permissions(user_id: int, db: Session = Depends(get_db)):
    permissions = db.query(Permission).filter(Permission.user_id == user_id).all()
    return permissions

@router.delete("/{permission_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_permission(permission_id: int, user_id: int, db: Session = Depends(get_db)):
    db_permission = db.query(Permission).filter(Permission.id == permission_id, Permission.user_id == user_id).first()
    if not db_permission:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Permission not found")
    db.delete(db_permission)
    db.commit()

===============================================
File: app\api\receipts.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.db.database import get_db
from typing import Dict

router = APIRouter(prefix="/receipts", tags=["receipts"])

@router.post("/upload", response_model=Dict)
async def upload_receipt(receipt: Dict, user_id: int, db: Session = Depends(get_db)):
    # Placeholder for receipt processing (e.g., OCR integration)
    return {
        "user_id": user_id,
        "message": "Receipt upload placeholder"
    }

===============================================
File: app\api\savings.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.saving import Saving
from app.db.schemas.saving import SavingCreate, Saving

router = APIRouter(prefix="/savings", tags=["savings"])

@router.post("/", response_model=Saving, status_code=status.HTTP_201_CREATED)
async def create_saving(saving: SavingCreate, user_id: int, db: Session = Depends(get_db)):
    db_saving = Saving(**saving.dict(), user_id=user_id)
    db.add(db_saving)
    db.commit()
    db.refresh(db_saving)
    return db_saving

@router.get("/{saving_id}", response_model=Saving)
async def get_saving(saving_id: int, user_id: int, db: Session = Depends(get_db)):
    saving = db.query(Saving).filter(Saving.id == saving_id, Saving.user_id == user_id).first()
    if not saving:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Saving not found")
    return saving

@router.get("/", response_model=List[Saving])
async def get_savings(user_id: int, db: Session = Depends(get_db)):
    savings = db.query(Saving).filter(Saving.user_id == user_id).all()
    return savings

@router.put("/{saving_id}", response_model=Saving)
async def update_saving(saving_id: int, saving: SavingCreate, user_id: int, db: Session = Depends(get_db)):
    db_saving = db.query(Saving).filter(Saving.id == saving_id, Saving.user_id == user_id).first()
    if not db_saving:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Saving not found")
    for key, value in saving.dict().items():
        setattr(db_saving, key, value)
    db.commit()
    db.refresh(db_saving)
    return db_saving

@router.delete("/{saving_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_saving(saving_id: int, user_id: int, db: Session = Depends(get_db)):
    db_saving = db.query(Saving).filter(Saving.id == saving_id, Saving.user_id == user_id).first()
    if not db_saving:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Saving not found")
    db.delete(db_saving)
    db.commit()

===============================================
File: app\api\sms.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.db.database import get_db
from typing import Dict

router = APIRouter(prefix="/sms", tags=["sms"])

@router.post("/send", response_model=Dict)
async def send_sms(sms: Dict, user_id: int, db: Session = Depends(get_db)):
    # Placeholder for SMS sending (e.g., Twilio integration)
    return {
        "user_id": user_id,
        "message": "SMS send placeholder"
    }

===============================================
File: app\api\split_expenses.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.split_expense import SplitExpense
from app.db.schemas.split_expense import SplitExpenseCreate, SplitExpense

router = APIRouter(prefix="/split_expenses", tags=["split_expenses"])

@router.post("/", response_model=SplitExpense, status_code=status.HTTP_201_CREATED)
async def create_split_expense(split_expense: SplitExpenseCreate, user_id: int, db: Session = Depends(get_db)):
    db_split = SplitExpense(**split_expense.dict(), user_id=user_id)
    db.add(db_split)
    db.commit()
    db.refresh(db_split)
    return db_split

@router.get("/{split_id}", response_model=SplitExpense)
async def get_split_expense(split_id: int, user_id: int, db: Session = Depends(get_db)):
    split = db.query(SplitExpense).filter(SplitExpense.id == split_id, SplitExpense.user_id == user_id).first()
    if not split:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Split expense not found")
    return split

@router.get("/", response_model=List[SplitExpense])
async def get_split_expenses(user_id: int, db: Session = Depends(get_db)):
    splits = db.query(SplitExpense).filter(SplitExpense.user_id == user_id).all()
    return splits

@router.put("/{split_id}", response_model=SplitExpense)
async def update_split_expense(split_id: int, split_expense: SplitExpenseCreate, user_id: int, db: Session = Depends(get_db)):
    db_split = db.query(SplitExpense).filter(SplitExpense.id == split_id, SplitExpense.user_id == user_id).first()
    if not db_split:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Split expense not found")
    for key, value in split_expense.dict().items():
        setattr(db_split, key, value)
    db.commit()
    db.refresh(db_split)
    return db_split

@router.delete("/{split_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_split_expense(split_id: int, user_id: int, db: Session = Depends(get_db)):
    db_split = db.query(SplitExpense).filter(SplitExpense.id == split_id, SplitExpense.user_id == user_id).first()
    if not db_split:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Split expense not found")
    db.delete(db_split)
    db.commit()

===============================================
File: app\api\subscriptions.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.debt import Debt
from app.db.schemas.debt import DebtCreate, Debt

router = APIRouter(prefix="/debts", tags=["debts"])

@router.post("/", response_model=Debt, status_code=status.HTTP_201_CREATED)
async def create_debt(debt: DebtCreate, user_id: int, db: Session = Depends(get_db)):
    db_debt = Debt(**debt.dict(), user_id=user_id)
    db.add(db_debt)
    db.commit()
    db.refresh(db_debt)
    return db_debt

@router.get("/{debt_id}", response_model=Debt)
async def get_debt(debt_id: int, user_id: int, db: Session = Depends(get_db)):
    debt = db.query(Debt).filter(Debt.id == debt_id, Debt.user_id == user_id).first()
    if not debt:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Debt not found")
    return debt

@router.get("/", response_model=List[Debt])
async def get_debts(user_id: int, db: Session = Depends(get_db)):
    debts = db.query(Debt).filter(Debt.user_id == user_id).all()
    return debts

@router.put("/{debt_id}", response_model=Debt)
async def update_debt(debt_id: int, debt: DebtCreate, user_id: int, db: Session = Depends(get_db)):
    db_debt = db.query(Debt).filter(Debt.id == debt_id, Debt.user_id == user_id).first()
    if not db_debt:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Debt not found")
    for key, value in debt.dict().items():
        setattr(db_debt, key, value)
    db.commit()
    db.refresh(db_debt)
    return db_debt

@router.delete("/{debt_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_debt(debt_id: int, user_id: int, db: Session = Depends(get_db)):
    db_debt = db.query(Debt).filter(Debt.id == debt_id, Debt.user_id == user_id).first()
    if not db_debt:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Debt not found")
    db.delete(db_debt)
    db.commit()

===============================================
File: app\api\templates.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.template import Template
from app.db.schemas.template import TemplateCreate, Template

router = APIRouter(prefix="/templates", tags=["templates"])

@router.post("/", response_model=Template, status_code=status.HTTP_201_CREATED)
async def create_template(template: TemplateCreate, user_id: int, db: Session = Depends(get_db)):
    db_template = Template(**template.dict(), user_id=user_id)
    db.add(db_template)
    db.commit()
    db.refresh(db_template)
    return db_template

@router.get("/{template_id}", response_model=Template)
async def get_template(template_id: int, user_id: int, db: Session = Depends(get_db)):
    template = db.query(Template).filter(Template.id == template_id, Template.user_id == user_id).first()
    if not template:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Template not found")
    return template

@router.get("/", response_model=List[Template])
async def get_templates(user_id: int, db: Session = Depends(get_db)):
    templates = db.query(Template).filter(Template.user_id == user_id).all()
    return templates

@router.put("/{template_id}", response_model=Template)
async def update_template(template_id: int, template: TemplateCreate, user_id: int, db: Session = Depends(get_db)):
    db_template = db.query(Template).filter(Template.id == template_id, Template.user_id == user_id).first()
    if not db_template:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Template not found")
    for key, value in template.dict().items():
        setattr(db_template, key, value)
    db.commit()
    db.refresh(db_template)
    return db_template

@router.delete("/{template_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_template(template_id: int, user_id: int, db: Session = Depends(get_db)):
    db_template = db.query(Template).filter(Template.id == template_id, Template.user_id == user_id).first()
    if not db_template:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Template not found")
    db.delete(db_template)
    db.commit()

===============================================
File: app\api\transactions.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.transaction import Transaction
from app.db.schemas.transaction import TransactionCreate, Transaction

router = APIRouter(prefix="/transactions", tags=["transactions"])

@router.post("/", response_model=Transaction, status_code=status.HTTP_201_CREATED)
async def create_transaction(transaction: TransactionCreate, user_id: int, db: Session = Depends(get_db)):
    db_transaction = Transaction(**transaction.dict(), user_id=user_id)
    db.add(db_transaction)
    db.commit()
    db.refresh(db_transaction)
    return db_transaction

@router.get("/{transaction_id}", response_model=Transaction)
async def get_transaction(transaction_id: int, user_id: int, db: Session = Depends(get_db)):
    transaction = db.query(Transaction).filter(Transaction.id == transaction_id, Transaction.user_id == user_id).first()
    if not transaction:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Transaction not found")
    return transaction

@router.get("/", response_model=List[Transaction])
async def get_transactions(user_id: int, db: Session = Depends(get_db)):
    transactions = db.query(Transaction).filter(Transaction.user_id == user_id).all()
    return transactions

@router.put("/{transaction_id}", response_model=Transaction)
async def update_transaction(transaction_id: int, transaction: TransactionCreate, user_id: int, db: Session = Depends(get_db)):
    db_transaction = db.query(Transaction).filter(Transaction.id == transaction_id, Transaction.user_id == user_id).first()
    if not db_transaction:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Transaction not found")
    for key, value in transaction.dict().items():
        setattr(db_transaction, key, value)
    db.commit()
    db.refresh(db_transaction)
    return db_transaction

@router.delete("/{transaction_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_transaction(transaction_id: int, user_id: int, db: Session = Depends(get_db)):
    db_transaction = db.query(Transaction).filter(Transaction.id == transaction_id, Transaction.user_id == user_id).first()
    if not db_transaction:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Transaction not found")
    db.delete(db_transaction)
    db.commit()

===============================================
File: app\api\widgets.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.widget_config import WidgetConfig
from app.db.schemas.widget_config import WidgetConfigCreate, WidgetConfig

router = APIRouter(prefix="/widgets", tags=["widgets"])

@router.post("/", response_model=WidgetConfig, status_code=status.HTTP_201_CREATED)
async def create_widget(widget: WidgetConfigCreate, user_id: int, db: Session = Depends(get_db)):
    db_widget = WidgetConfig(**widget.dict(), user_id=user_id)
    db.add(db_widget)
    db.commit()
    db.refresh(db_widget)
    return db_widget

@router.get("/{widget_id}", response_model=WidgetConfig)
async def get_widget(widget_id: int, user_id: int, db: Session = Depends(get_db)):
    widget = db.query(WidgetConfig).filter(WidgetConfig.id == widget_id, WidgetConfig.user_id == user_id).first()
    if not widget:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Widget not found")
    return widget

@router.get("/", response_model=List[WidgetConfig])
async def get_widgets(user_id: int, db: Session = Depends(get_db)):
    widgets = db.query(WidgetConfig).filter(WidgetConfig.user_id == user_id).all()
    return widgets

@router.put("/{widget_id}", response_model=WidgetConfig)
async def update_widget(widget_id: int, widget: WidgetConfigCreate, user_id: int, db: Session = Depends(get_db)):
    db_widget = db.query(WidgetConfig).filter(WidgetConfig.id == widget_id, WidgetConfig.user_id == user_id).first()
    if not db_widget:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Widget not found")
    for key, value in widget.dict().items():
        setattr(db_widget, key, value)
    db.commit()
    db.refresh(db_widget)
    return db_widget

@router.delete("/{widget_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_widget(widget_id: int, user_id: int, db: Session = Depends(get_db)):
    db_widget = db.query(WidgetConfig).filter(WidgetConfig.id == widget_id, WidgetConfig.user_id == user_id).first()
    if not db_widget:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Widget not found")
    db.delete(db_widget)
    db.commit()


===============================================
File: app\config\__init__.py
===============================================



===============================================
File: app\config\settings.py
===============================================



===============================================
File: app\db\__init__.py
===============================================



===============================================
File: app\db\create_tables.py
===============================================

from app.db.database import init_db
from app.db.models import *  # Import all models to register them

if __name__ == "__main__":
    init_db()
    print("Tables created successfully!")

===============================================
File: app\db\database.py
===============================================

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from dotenv import load_dotenv
import os

# Load .env file
load_dotenv()

# Database configuration
DATABASE_URL = os.getenv("DATABASE_URL")
DB_POOL_SIZE = int(os.getenv("DB_POOL_SIZE", 20))
DB_MAX_OVERFLOW = int(os.getenv("DB_MAX_OVERFLOW", 10))
DB_ECHO = os.getenv("DB_ECHO", "False").lower() == "true"

# Create SQLAlchemy engine
engine = create_engine(
    DATABASE_URL,
    pool_size=DB_POOL_SIZE,
    max_overflow=DB_MAX_OVERFLOW,
    echo=DB_ECHO
)

# Create session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Base class for models
Base = declarative_base()

# Dependency for FastAPI
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Function to initialize database (create tables)
def init_db():
    Base.metadata.create_all(bind=engine)

===============================================
File: app\db\test_db_connection.py
===============================================

import os
import ssl
import asyncio
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy import text  # <-- Important!
from dotenv import load_dotenv

# Load environment variables from ../../.env
load_dotenv(dotenv_path=os.path.join(os.path.dirname(__file__), '../../.env'))

DATABASE_URL = os.getenv("DATABASE_URL")
if DATABASE_URL and not DATABASE_URL.startswith("postgresql+asyncpg"):
    DATABASE_URL = DATABASE_URL.replace("postgresql://", "postgresql+asyncpg://", 1)

def get_ssl_context():
    ca_path = os.path.join(os.path.dirname(__file__), '../../ca.pem')
    if not os.path.exists(ca_path):
        print(f"❌ CA certificate not found at {ca_path}")
        print("Please download ca.pem from your Aiven dashboard and place it in the backend directory.")
        exit(1)
    ssl_context = ssl.create_default_context(cafile=ca_path)
    return ssl_context

async def test_connection():
    print(f"Trying: {DATABASE_URL}")
    ssl_context = get_ssl_context()
    engine = create_async_engine(
        DATABASE_URL or "bad_url",
        echo=True,
        connect_args={"ssl": ssl_context}
    )
    try:
        async with engine.begin() as conn:
            # FIX: wrap SQL string in text()
            await conn.execute(text("SELECT 1;"))
        print("✅ Database connection successful!")
    except SQLAlchemyError as e:
        print("❌ Database connection failed!")
        print(repr(e))

if __name__ == "__main__":
    asyncio.run(test_connection())



===============================================
File: app\db\models\__init__.py
===============================================

from .user import User
from .transaction import Transaction
from .debt import Debt
from .split_expense import SplitExpense
from .subscription import Subscription
from .budget import Budget
from .goal import Goal
from .saving import Saving
from .friend import Friend
from .message import Message
from .nudge import Nudge
from .permission import Permission
from .template import Template
from .widget_config import WidgetConfig

===============================================
File: app\db\models\budget.py
===============================================

from sqlalchemy import Column, Integer, String, Float, Date, DateTime
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base

class Budget(Base):
    __tablename__ = "budgets"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    category = Column(String, nullable=False)
    amount = Column(Float, nullable=False)
    period = Column(String, nullable=False)  # monthly/weekly
    start_date = Column(Date, nullable=False)
    end_date = Column(Date, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="budgets")

===============================================
File: app\db\models\debt.py
===============================================

from sqlalchemy import Column, Integer, String, Float, Date, DateTime, Enum
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base
import enum

class DebtStatus(enum.Enum):
    pending = "pending"
    paid = "paid"

class Debt(Base):
    __tablename__ = "debts"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    friend_id = Column(Integer, ForeignKey("friends.id"), index=True, nullable=True)
    amount = Column(Float, nullable=False)
    description = Column(String, nullable=True)
    due_date = Column(Date, nullable=True)
    status = Column(Enum(DebtStatus), nullable=False, default=DebtStatus.pending)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="debts")
    friend = relationship("Friend", back_populates="debts")

===============================================
File: app\db\models\friend.py
===============================================

from sqlalchemy import Column, Integer, String, Boolean, DateTime
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base

class Friend(Base):
    __tablename__ = "friends"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    name = Column(String, nullable=False)
    phone_number = Column(String, nullable=True)
    avatar_url = Column(String, nullable=True)
    is_online = Column(Boolean, default=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="friends")
    debts = relationship("Debt", back_populates="friend")
    messages = relationship("Message", back_populates="friend")

===============================================
File: app\db\models\goal.py
===============================================

from sqlalchemy import Column, Integer, String, Float, Date, DateTime
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base

class Goal(Base):
    __tablename__ = "goals"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    name = Column(String, nullable=False)
    target_amount = Column(Float, nullable=False)
    current_amount = Column(Float, nullable=False, default=0.0)
    target_date = Column(Date, nullable=False)
    category = Column(String, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="goals")
    savings = relationship("Saving", back_populates="goal")

===============================================
File: app\db\models\message.py
===============================================

from sqlalchemy import Column, Integer, String, Boolean, DateTime
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base

class Message(Base):
    __tablename__ = "messages"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    friend_id = Column(Integer, ForeignKey("friends.id"), nullable=True)
    content = Column(String, nullable=False)
    is_user = Column(Boolean, nullable=False)  # True for user, False for AI
    timestamp = Column(DateTime(timezone=True), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="messages")
    friend = relationship("Friend", back_populates="messages")

===============================================
File: app\db\models\nudge.py
===============================================

from sqlalchemy import Column, Integer, String, Enum, DateTime
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base
import enum

class NudgeStatus(enum.Enum):
    active = "active"
    dismissed = "dismissed"

class Nudge(Base):
    __tablename__ = "nudges"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    type = Column(String, nullable=False)  # e.g., debt_due, savings_goal
    content = Column(String, nullable=False)
    status = Column(Enum(NudgeStatus), nullable=False, default=NudgeStatus.active)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="nudges")

===============================================
File: app\db\models\permission.py
===============================================

from sqlalchemy import Column, Integer, String, DateTime
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base

class Permission(Base):
    __tablename__ = "permissions"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    resource_id = Column(Integer, nullable=False)
    resource_type = Column(String, nullable=False)  # e.g., split_expense, budget
    permission_type = Column(String, nullable=False)  # view/edit
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="permissions")

===============================================
File: app\db\models\saving.py
===============================================

from sqlalchemy import Column, Integer, String, Float, DateTime
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base

class Saving(Base):
    __tablename__ = "savings"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    name = Column(String, nullable=False)
    amount = Column(Float, nullable=False)
    goal_id = Column(Integer, ForeignKey("goals.id"), nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="savings")
    goal = relationship("Goal", back_populates="savings")

===============================================
File: app\db\models\split_expense.py
===============================================

from sqlalchemy import Column, Integer, String, Float, DateTime, Enum, JSON
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base
import enum

class SplitType(enum.Enum):
    equal = "equal"
    percentage = "percentage"
    custom = "custom"

class SplitExpense(Base):
    __tablename__ = "split_expenses"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    description = Column(String, nullable=False)
    total_amount = Column(Float, nullable=False)
    split_type = Column(Enum(SplitType), nullable=False)
    participants = Column(JSON, nullable=False)  # Stores list of {user_id, amount_paid, share_amount}
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="split_expenses")

===============================================
File: app\db\models\subscription.py
===============================================

from sqlalchemy import Column, Integer, String, Float, Date, DateTime, Enum
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base
import enum

class SubscriptionStatus(enum.Enum):
    active = "active"
    paused = "paused"
    cancelled = "cancelled"

class Subscription(Base):
    __tablename__ = "subscriptions"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    name = Column(String, nullable=False)
    amount = Column(Float, nullable=False)
    billing_cycle = Column(String, nullable=False)  # monthly/yearly/weekly
    next_due_date = Column(Date, nullable=False)
    category = Column(String, nullable=True)
    status = Column(Enum(SubscriptionStatus), nullable=False, default=SubscriptionStatus.active)
    color = Column(String, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="subscriptions")

===============================================
File: app\db\models\template.py
===============================================

from sqlalchemy import Column, Integer, String, Float, DateTime
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base

class Template(Base):
    __tablename__ = "templates"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    name = Column(String, nullable=False)
    category = Column(String, nullable=True)
    amount = Column(Float, nullable=True)
    description = Column(String, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="templates")

===============================================
File: app\db\models\transaction.py
===============================================

from sqlalchemy import Column, Integer, String, Float, DateTime, Enum
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base
import enum

class TransactionType(enum.Enum):
    expense = "expense"
    income = "income"

class Transaction(Base):
    __tablename__ = "transactions"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    amount = Column(Float, nullable=False)
    description = Column(String, nullable=True)
    category = Column(String, nullable=True)
    merchant_name = Column(String, nullable=True)
    bank_name = Column(String, nullable=True)
    confidence = Column(String, nullable=True)  # high/medium/low
    type = Column(Enum(TransactionType), nullable=False)
    timestamp = Column(DateTime(timezone=True), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="transactions")

===============================================
File: app\db\models\user.py
===============================================

from sqlalchemy import Column, String, Integer, DateTime
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from app.db.database import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, nullable=False)
    email = Column(String, unique=True, index=True, nullable=False)
    password_hash = Column(String, nullable=False)
    phone_number = Column(String, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    transactions = relationship("Transaction", back_populates="user")
    debts = relationship("Debt", back_populates="user")
    split_expenses = relationship("SplitExpense", back_populates="user")
    subscriptions = relationship("Subscription", back_populates="user")
    budgets = relationship("Budget", back_populates="user")
    goals = relationship("Goal", back_populates="user")
    savings = relationship("Saving", back_populates="user")
    friends = relationship("Friend", back_populates="user")
    messages = relationship("Message", back_populates="user")
    nudges = relationship("Nudge", back_populates="user")
    permissions = relationship("Permission", back_populates="user")
    templates = relationship("Template", back_populates="user")
    widget_configs = relationship("WidgetConfig", back_populates="user")

===============================================
File: app\db\models\widget_config.py
===============================================

from sqlalchemy import Column, Integer, String, JSON, DateTime
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base

class WidgetConfig(Base):
    __tablename__ = "widget_configs"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    widget_type = Column(String, nullable=False)
    position = Column(Integer, nullable=False)
    settings = Column(JSON, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="widget_configs")


===============================================
File: app\db\schemas\__init__.py
===============================================

from .user import User, UserCreate
from .transaction import Transaction, TransactionCreate
from .debt import Debt, DebtCreate
from .split_expense import SplitExpense, SplitExpenseCreate
from .subscription import Subscription, SubscriptionCreate, SubscriptionUpdate
from .budget import Budget, BudgetCreate
from .goal import Goal, GoalCreate
from .saving import Saving, SavingCreate
from .friend import Friend, FriendCreate
from .message import Message, MessageCreate
from .nudge import Nudge, NudgeCreate
from .permission import Permission, PermissionCreate
from .template import Template, TemplateCreate
from .widget_config import WidgetConfig, WidgetConfigCreate

===============================================
File: app\db\schemas\budget.py
===============================================

from pydantic import BaseModel
from datetime import datetime, date
from typing import Optional

class BudgetBase(BaseModel):
    category: str
    amount: float
    period: str  # monthly/weekly
    start_date: date
    end_date: date

class BudgetCreate(BudgetBase):
    pass

class Budget(BudgetBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\debt.py
===============================================

from pydantic import BaseModel
from datetime import datetime, date
from typing import Optional
from enum import Enum

class DebtStatus(str, Enum):
    pending = "pending"
    paid = "paid"

class DebtBase(BaseModel):
    amount: float
    description: Optional[str] = None
    due_date: Optional[date] = None
    status: DebtStatus = DebtStatus.pending

class DebtCreate(DebtBase):
    friend_id: Optional[int] = None

class Debt(DebtBase):
    id: int
    user_id: int
    friend_id: Optional[int] = None
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\friend.py
===============================================

from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class FriendBase(BaseModel):
    name: str
    phone_number: Optional[str] = None
    avatar_url: Optional[str] = None
    is_online: bool = False

class FriendCreate(FriendBase):
    pass

class Friend(FriendBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\goal.py
===============================================

from pydantic import BaseModel
from datetime import datetime, date
from typing import Optional

class GoalBase(BaseModel):
    name: str
    target_amount: float
    current_amount: float = 0.0
    target_date: date
    category: Optional[str] = None

class GoalCreate(GoalBase):
    pass

class Goal(GoalBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\message.py
===============================================

from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class MessageBase(BaseModel):
    content: str
    is_user: bool
    timestamp: datetime

class MessageCreate(MessageBase):
    friend_id: Optional[int] = None

class Message(MessageBase):
    id: int
    user_id: int
    friend_id: Optional[int] = None
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\nudge.py
===============================================

from pydantic import BaseModel
from datetime import datetime
from typing import Optional
from enum import Enum

class NudgeStatus(str, Enum):
    active = "active"
    dismissed = "dismissed"

class NudgeBase(BaseModel):
    type: str  # e.g., debt_due, savings_goal
    content: str
    status: NudgeStatus = NudgeStatus.active

class NudgeCreate(NudgeBase):
    pass

class Nudge(NudgeBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\permission.py
===============================================

from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class PermissionBase(BaseModel):
    resource_id: int
    resource_type: str  # e.g., split_expense, budget
    permission_type: str  # view/edit

class PermissionCreate(PermissionBase):
    pass

class Permission(PermissionBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\saving.py
===============================================

from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class SavingBase(BaseModel):
    name: str
    amount: float
    goal_id: Optional[int] = None

class SavingCreate(SavingBase):
    pass

class Saving(SavingBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\split_expense.py
===============================================

from pydantic import BaseModel
from datetime import datetime
from typing import List, Dict, Optional
from enum import Enum

class SplitType(str, Enum):
    equal = "equal"
    percentage = "percentage"
    custom = "custom"

class SplitExpenseBase(BaseModel):
    description: str
    total_amount: float
    split_type: SplitType
    participants: List[Dict[str, float]]  # e.g., [{"user_id": 1, "amount_paid": 100, "share_amount": 50}]

class SplitExpenseCreate(SplitExpenseBase):
    pass

class SplitExpense(SplitExpenseBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\subscription.py
===============================================

from pydantic import BaseModel
from datetime import datetime, date
from typing import Optional
from enum import Enum

class SubscriptionStatus(str, Enum):
    active = "active"
    paused = "paused"
    cancelled = "cancelled"

class SubscriptionBase(BaseModel):
    name: str
    amount: float
    billing_cycle: str  # monthly/yearly/weekly
    next_due_date: date
    category: Optional[str] = None
    status: SubscriptionStatus = SubscriptionStatus.active
    color: Optional[str] = None

class SubscriptionCreate(SubscriptionBase):
    pass

class SubscriptionUpdate(SubscriptionBase):
    name: Optional[str] = None
    amount: Optional[float] = None
    billing_cycle: Optional[str] = None
    next_due_date: Optional[date] = None
    status: Optional[SubscriptionStatus] = None

class Subscription(SubscriptionBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\template.py
===============================================

from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class TemplateBase(BaseModel):
    name: str
    category: Optional[str] = None
    amount: Optional[float] = None
    description: Optional[str] = None

class TemplateCreate(TemplateBase):
    pass

class Template(TemplateBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\transaction.py
===============================================

from pydantic import BaseModel
from datetime import datetime
from typing import Optional
from enum import Enum

class TransactionType(str, Enum):
    expense = "expense"
    income = "income"

class TransactionBase(BaseModel):
    amount: float
    description: Optional[str] = None
    category: Optional[str] = None
    merchant_name: Optional[str] = None
    bank_name: Optional[str] = None
    confidence: Optional[str] = None  # high/medium/low
    type: TransactionType
    timestamp: datetime

class TransactionCreate(TransactionBase):
    pass

class Transaction(TransactionBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\user.py
===============================================

from pydantic import BaseModel, EmailStr
from datetime import datetime
from typing import Optional

class UserBase(BaseModel):
    username: str
    email: EmailStr
    phone_number: Optional[str] = None

class UserCreate(UserBase):
    password: str

class User(UserBase):
    id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\widget_config.py
===============================================

from pydantic import BaseModel
from datetime import datetime
from typing import Optional, Dict

class WidgetConfigBase(BaseModel):
    widget_type: str
    position: int
    settings: Optional[Dict] = None

class WidgetConfigCreate(WidgetConfigBase):
    pass

class WidgetConfig(WidgetConfigBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True


===============================================
File: app\middleware\__init__.py
===============================================



===============================================
File: app\middleware\auth.py
===============================================



===============================================
File: app\services\__init__.py
===============================================



===============================================
File: app\services\analytics_service.py
===============================================



===============================================
File: app\services\auth_service.py
===============================================



===============================================
File: app\services\budget_service.py
===============================================



===============================================
File: app\services\chat_service.py
===============================================



===============================================
File: app\services\debt_service.py
===============================================



===============================================
File: app\services\friend_service.py
===============================================



===============================================
File: app\services\goal_service.py
===============================================



===============================================
File: app\services\message_service.py
===============================================



===============================================
File: app\services\notification_service.py
===============================================



===============================================
File: app\services\split_service.py
===============================================



===============================================
File: app\services\subscription_service.py
===============================================



===============================================
File: app\services\transaction_service.py
===============================================



===============================================
File: app\utils\__init__.py
===============================================



===============================================
File: app\utils\helpers.py
===============================================



===============================================
File: tests\__init__.py
===============================================



===============================================
File: tests\test_analytics.py
===============================================



===============================================
File: tests\test_auth.py
===============================================

import pytest
import pytest_asyncio
from fastapi.testclient import TestClient
from fastapi import status
from app.db.database import get_db
from sqlalchemy.orm import Session
from app.db.models.user import User
from app.db.schemas.user import UserCreate
from main import app  # Import app for TestClient

@pytest_asyncio.fixture
async def client():
    return TestClient(app)

@pytest_asyncio.fixture
async def db_session():
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()

@pytest.mark.asyncio
async def test_signup_success(client: TestClient, db_session: Session):
    # Clean up existing user
    db_session.query(User).filter(User.email == "newuser@example.com").delete()
    db_session.commit()
    
    user_data = {
        "username": "newuser",
        "email": "newuser@example.com",
        "password": "password123",
        "phone_number": "9876543210"
    }
    response = client.post("/auth/signup", json=user_data)
    assert response.status_code == status.HTTP_201_CREATED
    assert response.json()["email"] == "newuser@example.com"
    db_user = db_session.query(User).filter(User.email == "newuser@example.com").first()
    assert db_user is not None
    assert db_user.username == "newuser"

@pytest.mark.asyncio
async def test_signup_duplicate_email(client: TestClient):
    user_data = {
        "username": "testuser",
        "email": "test@example.com",
        "password": "testpassword123",
        "phone_number": "9876543210"
    }
    response = client.post("/auth/signup", json=user_data)
    assert response.status_code == status.HTTP_400_BAD_REQUEST
    assert "already registered" in response.json()["detail"]

@pytest.mark.asyncio
async def test_login_success(client: TestClient):
    login_data = {
        "username": "testuser",
        "email": "test@example.com",
        "password": "testpassword123",
        "phone_number": "1234567890"
    }
    response = client.post("/auth/login", json=login_data)
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["message"] == "Login successful"
    assert "user_id" in response.json()

@pytest.mark.asyncio
async def test_login_invalid_credentials(client: TestClient):
    login_data = {
        "username": "testuser",
        "email": "test@example.com",
        "password": "wrongpassword",
        "phone_number": "1234567890"
    }
    response = client.post("/auth/login", json=login_data)
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "Invalid email or password" in response.json()["detail"]

===============================================
File: tests\test_budgets.py
===============================================



===============================================
File: tests\test_chat.py
===============================================



===============================================
File: tests\test_debts.py
===============================================



===============================================
File: tests\test_friends.py
===============================================



===============================================
File: tests\test_goals.py
===============================================



===============================================
File: tests\test_messages.py
===============================================



===============================================
File: tests\test_notifications.py
===============================================



===============================================
File: tests\test_receipts.py
===============================================



===============================================
File: tests\test_savings.py
===============================================



===============================================
File: tests\test_sms.py
===============================================



===============================================
File: tests\test_split_expenses.py
===============================================



===============================================
File: tests\test_subscriptions.py
===============================================



===============================================
File: tests\test_templates.py
===============================================



===============================================
File: tests\test_transactions.py
===============================================





===============================================
File: main.py
===============================================

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.db.database import init_db
from app.api.auth import router as auth_router
from app.api.transactions import router as transactions_router
from app.api.debts import router as debts_router
from app.api.split_expenses import router as split_expenses_router
from app.api.subscriptions import router as subscriptions_router
from app.api.budgets import router as budgets_router
from app.api.goals import router as goals_router
from app.api.savings import router as savings_router
from app.api.friends import router as friends_router
from app.api.messages import router as messages_router
from app.api.notifications import router as notifications_router
from app.api.permissions import router as permissions_router
from app.api.templates import router as templates_router
from app.api.widgets import router as widgets_router
from app.api.analytics import router as analytics_router
from app.api.dashboard import router as dashboard_router
from app.api.chat import router as chat_router
from app.api.receipts import router as receipts_router
from app.api.sms import router as sms_router

app = FastAPI(title="LogUp Backend")

# CORS for frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include all API routers
app.include_router(auth_router)
app.include_router(transactions_router)
app.include_router(debts_router)
app.include_router(split_expenses_router)
app.include_router(subscriptions_router)
app.include_router(budgets_router)
app.include_router(goals_router)
app.include_router(savings_router)
app.include_router(friends_router)
app.include_router(messages_router)
app.include_router(notifications_router)
app.include_router(permissions_router)
app.include_router(templates_router)
app.include_router(widgets_router)
app.include_router(analytics_router)
app.include_router(dashboard_router)
app.include_router(chat_router)
app.include_router(receipts_router)
app.include_router(sms_router)

@app.on_event("startup")
async def startup_event():
    init_db()

@app.get("/")
async def root():
    return {"message": "Welcome to LogUp Backend"}

===============================================
File: requirements.txt
===============================================

[Non-text file]

===============================================
File: app\__init__.py
===============================================




===============================================
File: app\api\__init__.py
===============================================

from .auth import router as auth_router
from .transactions import router as transactions_router
from .debts import router as debts_router
from .split_expenses import router as split_expenses_router
from .subscriptions import router as subscriptions_router
from .budgets import router as budgets_router
from .goals import router as goals_router
from .savings import router as savings_router
from .friends import router as friends_router
from .messages import router as messages_router
from .notifications import router as notifications_router
from .permissions import router as permissions_router
from .templates import router as templates_router
from .widgets import router as widgets_router
from .analytics import router as analytics_router
from .dashboard import router as dashboard_router
from .chat import router as chat_router
from .receipts import router as receipts_router
from .sms import router as sms_router

===============================================
File: app\api\analytics.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.db.database import get_db
from typing import Dict

router = APIRouter(prefix="/analytics", tags=["analytics"])

@router.get("/summary", response_model=Dict)
async def get_analytics_summary(user_id: int, db: Session = Depends(get_db)):
    # Placeholder for analytics summary (e.g., total expenses, savings, debts)
    return {
        "user_id": user_id,
        "total_expenses": 0.0,
        "total_savings": 0.0,
        "total_debts": 0.0
    }

===============================================
File: app\api\auth.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.db.database import get_db
from app.db.models.user import User
from app.db.schemas.user import UserCreate, User as UserSchema
from passlib.context import CryptContext

router = APIRouter(prefix="/auth", tags=["auth"])

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

@router.post("/signup", response_model=UserSchema, status_code=status.HTTP_201_CREATED)
async def signup(user: UserCreate, db: Session = Depends(get_db)):
    existing_user = db.query(User).filter(User.email == user.email).first()
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )
    
    hashed_password = pwd_context.hash(user.password)
    db_user = User(
        username=user.username,
        email=user.email,
        password_hash=hashed_password,
        phone_number=user.phone_number
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

@router.post("/login")
async def login(user: UserCreate, db: Session = Depends(get_db)):
    db_user = db.query(User).filter(User.email == user.email).first()
    if not db_user or not pwd_context.verify(user.password, db_user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password"
        )
    return {"message": "Login successful", "user_id": db_user.id}

===============================================
File: app\api\budgets.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.budget import Budget
from app.db.schemas.budget import BudgetCreate, Budget

router = APIRouter(prefix="/budgets", tags=["budgets"])

@router.post("/", response_model=Budget, status_code=status.HTTP_201_CREATED)
async def create_budget(budget: BudgetCreate, user_id: int, db: Session = Depends(get_db)):
    db_budget = Budget(**budget.dict(), user_id=user_id)
    db.add(db_budget)
    db.commit()
    db.refresh(db_budget)
    return db_budget

@router.get("/{budget_id}", response_model=Budget)
async def get_budget(budget_id: int, user_id: int, db: Session = Depends(get_db)):
    budget = db.query(Budget).filter(Budget.id == budget_id, Budget.user_id == user_id).first()
    if not budget:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Budget not found")
    return budget

@router.get("/", response_model=List[Budget])
async def get_budgets(user_id: int, db: Session = Depends(get_db)):
    budgets = db.query(Budget).filter(Budget.user_id == user_id).all()
    return budgets

@router.put("/{budget_id}", response_model=Budget)
async def update_budget(budget_id: int, budget: BudgetCreate, user_id: int, db: Session = Depends(get_db)):
    db_budget = db.query(Budget).filter(Budget.id == budget_id, Budget.user_id == user_id).first()
    if not db_budget:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Budget not found")
    for key, value in budget.dict().items():
        setattr(db_budget, key, value)
    db.commit()
    db.refresh(db_budget)
    return db_budget

@router.delete("/{budget_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_budget(budget_id: int, user_id: int, db: Session = Depends(get_db)):
    db_budget = db.query(Budget).filter(Budget.id == budget_id, Budget.user_id == user_id).first()
    if not db_budget:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Budget not found")
    db.delete(db_budget)
    db.commit()

===============================================
File: app\api\chat.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.db.database import get_db
from typing import Dict

router = APIRouter(prefix="/chat", tags=["chat"])

@router.post("/message", response_model=Dict)
async def send_chat_message(message: Dict, user_id: int, db: Session = Depends(get_db)):
    # Placeholder for AI chat processing (to be integrated with Qdrant later)
    return {
        "user_id": user_id,
        "message": message.get("content"),
        "response": "AI response placeholder"
    }

===============================================
File: app\api\dashboard.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.db.database import get_db
from typing import Dict

router = APIRouter(prefix="/analytics", tags=["analytics"])

@router.get("/summary", response_model=Dict)
async def get_analytics_summary(user_id: int, db: Session = Depends(get_db)):
    # Placeholder for analytics summary (e.g., total expenses, savings, debts)
    return {
        "user_id": user_id,
        "total_expenses": 0.0,
        "total_savings": 0.0,
        "total_debts": 0.0
    }

===============================================
File: app\api\debts.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.debt import Debt
from app.db.schemas.debt import DebtCreate, Debt

router = APIRouter(prefix="/debts", tags=["debts"])

@router.post("/", response_model=Debt, status_code=status.HTTP_201_CREATED)
async def create_debt(debt: DebtCreate, user_id: int, db: Session = Depends(get_db)):
    db_debt = Debt(**debt.dict(), user_id=user_id)
    db.add(db_debt)
    db.commit()
    db.refresh(db_debt)
    return db_debt

@router.get("/{debt_id}", response_model=Debt)
async def get_debt(debt_id: int, user_id: int, db: Session = Depends(get_db)):
    debt = db.query(Debt).filter(Debt.id == debt_id, Debt.user_id == user_id).first()
    if not debt:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Debt not found")
    return debt

@router.get("/", response_model=List[Debt])
async def get_debts(user_id: int, db: Session = Depends(get_db)):
    debts = db.query(Debt).filter(Debt.user_id == user_id).all()
    return debts

@router.put("/{debt_id}", response_model=Debt)
async def update_debt(debt_id: int, debt: DebtCreate, user_id: int, db: Session = Depends(get_db)):
    db_debt = db.query(Debt).filter(Debt.id == debt_id, Debt.user_id == user_id).first()
    if not db_debt:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Debt not found")
    for key, value in debt.dict().items():
        setattr(db_debt, key, value)
    db.commit()
    db.refresh(db_debt)
    return db_debt

@router.delete("/{debt_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_debt(debt_id: int, user_id: int, db: Session = Depends(get_db)):
    db_debt = db.query(Debt).filter(Debt.id == debt_id, Debt.user_id == user_id).first()
    if not db_debt:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Debt not found")
    db.delete(db_debt)
    db.commit()

===============================================
File: app\api\friends.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.friend import Friend
from app.db.schemas.friend import FriendCreate, Friend

router = APIRouter(prefix="/friends", tags=["friends"])

@router.post("/", response_model=Friend, status_code=status.HTTP_201_CREATED)
async def create_friend(friend: FriendCreate, user_id: int, db: Session = Depends(get_db)):
    db_friend = Friend(**friend.dict(), user_id=user_id)
    db.add(db_friend)
    db.commit()
    db.refresh(db_friend)
    return db_friend

@router.get("/{friend_id}", response_model=Friend)
async def get_friend(friend_id: int, user_id: int, db: Session = Depends(get_db)):
    friend = db.query(Friend).filter(Friend.id == friend_id, Friend.user_id == user_id).first()
    if not friend:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Friend not found")
    return friend

@router.get("/", response_model=List[Friend])
async def get_friends(user_id: int, db: Session = Depends(get_db)):
    friends = db.query(Friend).filter(Friend.user_id == user_id).all()
    return friends

@router.put("/{friend_id}", response_model=Friend)
async def update_friend(friend_id: int, friend: FriendCreate, user_id: int, db: Session = Depends(get_db)):
    db_friend = db.query(Friend).filter(Friend.id == friend_id, Friend.user_id == user_id).first()
    if not db_friend:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Friend not found")
    for key, value in friend.dict().items():
        setattr(db_friend, key, value)
    db.commit()
    db.refresh(db_friend)
    return db_friend

@router.delete("/{friend_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_friend(friend_id: int, user_id: int, db: Session = Depends(get_db)):
    db_friend = db.query(Friend).filter(Friend.id == friend_id, Friend.user_id == user_id).first()
    if not db_friend:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Friend not found")
    db.delete(db_friend)
    db.commit()

===============================================
File: app\api\goals.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.goal import Goal
from app.db.schemas.goal import GoalCreate, Goal

router = APIRouter(prefix="/goals", tags=["goals"])

@router.post("/", response_model=Goal, status_code=status.HTTP_201_CREATED)
async def create_goal(goal: GoalCreate, user_id: int, db: Session = Depends(get_db)):
    db_goal = Goal(**goal.dict(), user_id=user_id)
    db.add(db_goal)
    db.commit()
    db.refresh(db_goal)
    return db_goal

@router.get("/{goal_id}", response_model=Goal)
async def get_goal(goal_id: int, user_id: int, db: Session = Depends(get_db)):
    goal = db.query(Goal).filter(Goal.id == goal_id, Goal.user_id == user_id).first()
    if not goal:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Goal not found")
    return goal

@router.get("/", response_model=List[Goal])
async def get_goals(user_id: int, db: Session = Depends(get_db)):
    goals = db.query(Goal).filter(Goal.user_id == user_id).all()
    return goals

@router.put("/{goal_id}", response_model=Goal)
async def update_goal(goal_id: int, goal: GoalCreate, user_id: int, db: Session = Depends(get_db)):
    db_goal = db.query(Goal).filter(Goal.id == goal_id, Goal.user_id == user_id).first()
    if not db_goal:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Goal not found")
    for key, value in goal.dict().items():
        setattr(db_goal, key, value)
    db.commit()
    db.refresh(db_goal)
    return db_goal

@router.delete("/{goal_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_goal(goal_id: int, user_id: int, db: Session = Depends(get_db)):
    db_goal = db.query(Goal).filter(Goal.id == goal_id, Goal.user_id == user_id).first()
    if not db_goal:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Goal not found")
    db.delete(db_goal)
    db.commit()

===============================================
File: app\api\messages.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.message import Message
from app.db.schemas.message import MessageCreate, Message

router = APIRouter(prefix="/messages", tags=["messages"])

@router.post("/", response_model=Message, status_code=status.HTTP_201_CREATED)
async def create_message(message: MessageCreate, user_id: int, db: Session = Depends(get_db)):
    db_message = Message(**message.dict(), user_id=user_id)
    db.add(db_message)
    db.commit()
    db.refresh(db_message)
    return db_message

@router.get("/{message_id}", response_model=Message)
async def get_message(message_id: int, user_id: int, db: Session = Depends(get_db)):
    message = db.query(Message).filter(Message.id == message_id, Message.user_id == user_id).first()
    if not message:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Message not found")
    return message

@router.get("/", response_model=List[Message])
async def get_messages(user_id: int, db: Session = Depends(get_db)):
    messages = db.query(Message).filter(Message.user_id == user_id).all()
    return messages

@router.delete("/{message_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_message(message_id: int, user_id: int, db: Session = Depends(get_db)):
    db_message = db.query(Message).filter(Message.id == message_id, Message.user_id == user_id).first()
    if not db_message:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Message not found")
    db.delete(db_message)
    db.commit()

===============================================
File: app\api\notifications.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.nudge import Nudge
from app.db.schemas.nudge import NudgeCreate, Nudge

router = APIRouter(prefix="/notifications", tags=["notifications"])

@router.post("/", response_model=Nudge, status_code=status.HTTP_201_CREATED)
async def create_notification(nudge: NudgeCreate, user_id: int, db: Session = Depends(get_db)):
    db_nudge = Nudge(**nudge.dict(), user_id=user_id)
    db.add(db_nudge)
    db.commit()
    db.refresh(db_nudge)
    return db_nudge

@router.get("/{nudge_id}", response_model=Nudge)
async def get_notification(nudge_id: int, user_id: int, db: Session = Depends(get_db)):
    nudge = db.query(Nudge).filter(Nudge.id == nudge_id, Nudge.user_id == user_id).first()
    if not nudge:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Notification not found")
    return nudge

@router.get("/", response_model=List[Nudge])
async def get_notifications(user_id: int, db: Session = Depends(get_db)):
    nudges = db.query(Nudge).filter(Nudge.user_id == user_id).all()
    return nudges

@router.put("/{nudge_id}", response_model=Nudge)
async def update_notification(nudge_id: int, nudge: NudgeCreate, user_id: int, db: Session = Depends(get_db)):
    db_nudge = db.query(Nudge).filter(Nudge.id == nudge_id, Nudge.user_id == user_id).first()
    if not db_nudge:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Notification not found")
    for key, value in nudge.dict().items():
        setattr(db_nudge, key, value)
    db.commit()
    db.refresh(db_nudge)
    return db_nudge

@router.delete("/{nudge_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_notification(nudge_id: int, user_id: int, db: Session = Depends(get_db)):
    db_nudge = db.query(Nudge).filter(Nudge.id == nudge_id, Nudge.user_id == user_id).first()
    if not db_nudge:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Notification not found")
    db.delete(db_nudge)
    db.commit()

===============================================
File: app\api\permissions.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.permission import Permission
from app.db.schemas.permission import PermissionCreate, Permission

router = APIRouter(prefix="/permissions", tags=["permissions"])

@router.post("/", response_model=Permission, status_code=status.HTTP_201_CREATED)
async def create_permission(permission: PermissionCreate, user_id: int, db: Session = Depends(get_db)):
    db_permission = Permission(**permission.dict(), user_id=user_id)
    db.add(db_permission)
    db.commit()
    db.refresh(db_permission)
    return db_permission

@router.get("/{permission_id}", response_model=Permission)
async def get_permission(permission_id: int, user_id: int, db: Session = Depends(get_db)):
    permission = db.query(Permission).filter(Permission.id == permission_id, Permission.user_id == user_id).first()
    if not permission:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Permission not found")
    return permission

@router.get("/", response_model=List[Permission])
async def get_permissions(user_id: int, db: Session = Depends(get_db)):
    permissions = db.query(Permission).filter(Permission.user_id == user_id).all()
    return permissions

@router.delete("/{permission_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_permission(permission_id: int, user_id: int, db: Session = Depends(get_db)):
    db_permission = db.query(Permission).filter(Permission.id == permission_id, Permission.user_id == user_id).first()
    if not db_permission:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Permission not found")
    db.delete(db_permission)
    db.commit()

===============================================
File: app\api\receipts.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.db.database import get_db
from typing import Dict

router = APIRouter(prefix="/receipts", tags=["receipts"])

@router.post("/upload", response_model=Dict)
async def upload_receipt(receipt: Dict, user_id: int, db: Session = Depends(get_db)):
    # Placeholder for receipt processing (e.g., OCR integration)
    return {
        "user_id": user_id,
        "message": "Receipt upload placeholder"
    }

===============================================
File: app\api\savings.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.saving import Saving
from app.db.schemas.saving import SavingCreate, Saving

router = APIRouter(prefix="/savings", tags=["savings"])

@router.post("/", response_model=Saving, status_code=status.HTTP_201_CREATED)
async def create_saving(saving: SavingCreate, user_id: int, db: Session = Depends(get_db)):
    db_saving = Saving(**saving.dict(), user_id=user_id)
    db.add(db_saving)
    db.commit()
    db.refresh(db_saving)
    return db_saving

@router.get("/{saving_id}", response_model=Saving)
async def get_saving(saving_id: int, user_id: int, db: Session = Depends(get_db)):
    saving = db.query(Saving).filter(Saving.id == saving_id, Saving.user_id == user_id).first()
    if not saving:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Saving not found")
    return saving

@router.get("/", response_model=List[Saving])
async def get_savings(user_id: int, db: Session = Depends(get_db)):
    savings = db.query(Saving).filter(Saving.user_id == user_id).all()
    return savings

@router.put("/{saving_id}", response_model=Saving)
async def update_saving(saving_id: int, saving: SavingCreate, user_id: int, db: Session = Depends(get_db)):
    db_saving = db.query(Saving).filter(Saving.id == saving_id, Saving.user_id == user_id).first()
    if not db_saving:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Saving not found")
    for key, value in saving.dict().items():
        setattr(db_saving, key, value)
    db.commit()
    db.refresh(db_saving)
    return db_saving

@router.delete("/{saving_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_saving(saving_id: int, user_id: int, db: Session = Depends(get_db)):
    db_saving = db.query(Saving).filter(Saving.id == saving_id, Saving.user_id == user_id).first()
    if not db_saving:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Saving not found")
    db.delete(db_saving)
    db.commit()

===============================================
File: app\api\sms.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.db.database import get_db
from typing import Dict

router = APIRouter(prefix="/sms", tags=["sms"])

@router.post("/send", response_model=Dict)
async def send_sms(sms: Dict, user_id: int, db: Session = Depends(get_db)):
    # Placeholder for SMS sending (e.g., Twilio integration)
    return {
        "user_id": user_id,
        "message": "SMS send placeholder"
    }

===============================================
File: app\api\split_expenses.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.split_expense import SplitExpense
from app.db.schemas.split_expense import SplitExpenseCreate, SplitExpense

router = APIRouter(prefix="/split_expenses", tags=["split_expenses"])

@router.post("/", response_model=SplitExpense, status_code=status.HTTP_201_CREATED)
async def create_split_expense(split_expense: SplitExpenseCreate, user_id: int, db: Session = Depends(get_db)):
    db_split = SplitExpense(**split_expense.dict(), user_id=user_id)
    db.add(db_split)
    db.commit()
    db.refresh(db_split)
    return db_split

@router.get("/{split_id}", response_model=SplitExpense)
async def get_split_expense(split_id: int, user_id: int, db: Session = Depends(get_db)):
    split = db.query(SplitExpense).filter(SplitExpense.id == split_id, SplitExpense.user_id == user_id).first()
    if not split:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Split expense not found")
    return split

@router.get("/", response_model=List[SplitExpense])
async def get_split_expenses(user_id: int, db: Session = Depends(get_db)):
    splits = db.query(SplitExpense).filter(SplitExpense.user_id == user_id).all()
    return splits

@router.put("/{split_id}", response_model=SplitExpense)
async def update_split_expense(split_id: int, split_expense: SplitExpenseCreate, user_id: int, db: Session = Depends(get_db)):
    db_split = db.query(SplitExpense).filter(SplitExpense.id == split_id, SplitExpense.user_id == user_id).first()
    if not db_split:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Split expense not found")
    for key, value in split_expense.dict().items():
        setattr(db_split, key, value)
    db.commit()
    db.refresh(db_split)
    return db_split

@router.delete("/{split_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_split_expense(split_id: int, user_id: int, db: Session = Depends(get_db)):
    db_split = db.query(SplitExpense).filter(SplitExpense.id == split_id, SplitExpense.user_id == user_id).first()
    if not db_split:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Split expense not found")
    db.delete(db_split)
    db.commit()

===============================================
File: app\api\subscriptions.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.debt import Debt
from app.db.schemas.debt import DebtCreate, Debt

router = APIRouter(prefix="/debts", tags=["debts"])

@router.post("/", response_model=Debt, status_code=status.HTTP_201_CREATED)
async def create_debt(debt: DebtCreate, user_id: int, db: Session = Depends(get_db)):
    db_debt = Debt(**debt.dict(), user_id=user_id)
    db.add(db_debt)
    db.commit()
    db.refresh(db_debt)
    return db_debt

@router.get("/{debt_id}", response_model=Debt)
async def get_debt(debt_id: int, user_id: int, db: Session = Depends(get_db)):
    debt = db.query(Debt).filter(Debt.id == debt_id, Debt.user_id == user_id).first()
    if not debt:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Debt not found")
    return debt

@router.get("/", response_model=List[Debt])
async def get_debts(user_id: int, db: Session = Depends(get_db)):
    debts = db.query(Debt).filter(Debt.user_id == user_id).all()
    return debts

@router.put("/{debt_id}", response_model=Debt)
async def update_debt(debt_id: int, debt: DebtCreate, user_id: int, db: Session = Depends(get_db)):
    db_debt = db.query(Debt).filter(Debt.id == debt_id, Debt.user_id == user_id).first()
    if not db_debt:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Debt not found")
    for key, value in debt.dict().items():
        setattr(db_debt, key, value)
    db.commit()
    db.refresh(db_debt)
    return db_debt

@router.delete("/{debt_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_debt(debt_id: int, user_id: int, db: Session = Depends(get_db)):
    db_debt = db.query(Debt).filter(Debt.id == debt_id, Debt.user_id == user_id).first()
    if not db_debt:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Debt not found")
    db.delete(db_debt)
    db.commit()

===============================================
File: app\api\templates.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.template import Template
from app.db.schemas.template import TemplateCreate, Template

router = APIRouter(prefix="/templates", tags=["templates"])

@router.post("/", response_model=Template, status_code=status.HTTP_201_CREATED)
async def create_template(template: TemplateCreate, user_id: int, db: Session = Depends(get_db)):
    db_template = Template(**template.dict(), user_id=user_id)
    db.add(db_template)
    db.commit()
    db.refresh(db_template)
    return db_template

@router.get("/{template_id}", response_model=Template)
async def get_template(template_id: int, user_id: int, db: Session = Depends(get_db)):
    template = db.query(Template).filter(Template.id == template_id, Template.user_id == user_id).first()
    if not template:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Template not found")
    return template

@router.get("/", response_model=List[Template])
async def get_templates(user_id: int, db: Session = Depends(get_db)):
    templates = db.query(Template).filter(Template.user_id == user_id).all()
    return templates

@router.put("/{template_id}", response_model=Template)
async def update_template(template_id: int, template: TemplateCreate, user_id: int, db: Session = Depends(get_db)):
    db_template = db.query(Template).filter(Template.id == template_id, Template.user_id == user_id).first()
    if not db_template:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Template not found")
    for key, value in template.dict().items():
        setattr(db_template, key, value)
    db.commit()
    db.refresh(db_template)
    return db_template

@router.delete("/{template_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_template(template_id: int, user_id: int, db: Session = Depends(get_db)):
    db_template = db.query(Template).filter(Template.id == template_id, Template.user_id == user_id).first()
    if not db_template:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Template not found")
    db.delete(db_template)
    db.commit()

===============================================
File: app\api\transactions.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.transaction import Transaction
from app.db.schemas.transaction import TransactionCreate, Transaction

router = APIRouter(prefix="/transactions", tags=["transactions"])

@router.post("/", response_model=Transaction, status_code=status.HTTP_201_CREATED)
async def create_transaction(transaction: TransactionCreate, user_id: int, db: Session = Depends(get_db)):
    db_transaction = Transaction(**transaction.dict(), user_id=user_id)
    db.add(db_transaction)
    db.commit()
    db.refresh(db_transaction)
    return db_transaction

@router.get("/{transaction_id}", response_model=Transaction)
async def get_transaction(transaction_id: int, user_id: int, db: Session = Depends(get_db)):
    transaction = db.query(Transaction).filter(Transaction.id == transaction_id, Transaction.user_id == user_id).first()
    if not transaction:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Transaction not found")
    return transaction

@router.get("/", response_model=List[Transaction])
async def get_transactions(user_id: int, db: Session = Depends(get_db)):
    transactions = db.query(Transaction).filter(Transaction.user_id == user_id).all()
    return transactions

@router.put("/{transaction_id}", response_model=Transaction)
async def update_transaction(transaction_id: int, transaction: TransactionCreate, user_id: int, db: Session = Depends(get_db)):
    db_transaction = db.query(Transaction).filter(Transaction.id == transaction_id, Transaction.user_id == user_id).first()
    if not db_transaction:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Transaction not found")
    for key, value in transaction.dict().items():
        setattr(db_transaction, key, value)
    db.commit()
    db.refresh(db_transaction)
    return db_transaction

@router.delete("/{transaction_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_transaction(transaction_id: int, user_id: int, db: Session = Depends(get_db)):
    db_transaction = db.query(Transaction).filter(Transaction.id == transaction_id, Transaction.user_id == user_id).first()
    if not db_transaction:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Transaction not found")
    db.delete(db_transaction)
    db.commit()

===============================================
File: app\api\widgets.py
===============================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.db.models.widget_config import WidgetConfig
from app.db.schemas.widget_config import WidgetConfigCreate, WidgetConfig

router = APIRouter(prefix="/widgets", tags=["widgets"])

@router.post("/", response_model=WidgetConfig, status_code=status.HTTP_201_CREATED)
async def create_widget(widget: WidgetConfigCreate, user_id: int, db: Session = Depends(get_db)):
    db_widget = WidgetConfig(**widget.dict(), user_id=user_id)
    db.add(db_widget)
    db.commit()
    db.refresh(db_widget)
    return db_widget

@router.get("/{widget_id}", response_model=WidgetConfig)
async def get_widget(widget_id: int, user_id: int, db: Session = Depends(get_db)):
    widget = db.query(WidgetConfig).filter(WidgetConfig.id == widget_id, WidgetConfig.user_id == user_id).first()
    if not widget:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Widget not found")
    return widget

@router.get("/", response_model=List[WidgetConfig])
async def get_widgets(user_id: int, db: Session = Depends(get_db)):
    widgets = db.query(WidgetConfig).filter(WidgetConfig.user_id == user_id).all()
    return widgets

@router.put("/{widget_id}", response_model=WidgetConfig)
async def update_widget(widget_id: int, widget: WidgetConfigCreate, user_id: int, db: Session = Depends(get_db)):
    db_widget = db.query(WidgetConfig).filter(WidgetConfig.id == widget_id, WidgetConfig.user_id == user_id).first()
    if not db_widget:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Widget not found")
    for key, value in widget.dict().items():
        setattr(db_widget, key, value)
    db.commit()
    db.refresh(db_widget)
    return db_widget

@router.delete("/{widget_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_widget(widget_id: int, user_id: int, db: Session = Depends(get_db)):
    db_widget = db.query(WidgetConfig).filter(WidgetConfig.id == widget_id, WidgetConfig.user_id == user_id).first()
    if not db_widget:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Widget not found")
    db.delete(db_widget)
    db.commit()


===============================================
File: app\config\__init__.py
===============================================



===============================================
File: app\config\settings.py
===============================================



===============================================
File: app\db\__init__.py
===============================================



===============================================
File: app\db\create_tables.py
===============================================

from app.db.database import init_db
from app.db.models import *  # Import all models to register them

if __name__ == "__main__":
    init_db()
    print("Tables created successfully!")

===============================================
File: app\db\database.py
===============================================

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from dotenv import load_dotenv
import os

# Load .env file
load_dotenv()

# Database configuration
DATABASE_URL = os.getenv("DATABASE_URL")
DB_POOL_SIZE = int(os.getenv("DB_POOL_SIZE", 20))
DB_MAX_OVERFLOW = int(os.getenv("DB_MAX_OVERFLOW", 10))
DB_ECHO = os.getenv("DB_ECHO", "False").lower() == "true"

# Create SQLAlchemy engine
engine = create_engine(
    DATABASE_URL,
    pool_size=DB_POOL_SIZE,
    max_overflow=DB_MAX_OVERFLOW,
    echo=DB_ECHO
)

# Create session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Base class for models
Base = declarative_base()

# Dependency for FastAPI
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Function to initialize database (create tables)
def init_db():
    Base.metadata.create_all(bind=engine)

===============================================
File: app\db\test_db_connection.py
===============================================

import os
import ssl
import asyncio
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy import text  # <-- Important!
from dotenv import load_dotenv

# Load environment variables from ../../.env
load_dotenv(dotenv_path=os.path.join(os.path.dirname(__file__), '../../.env'))

DATABASE_URL = os.getenv("DATABASE_URL")
if DATABASE_URL and not DATABASE_URL.startswith("postgresql+asyncpg"):
    DATABASE_URL = DATABASE_URL.replace("postgresql://", "postgresql+asyncpg://", 1)

def get_ssl_context():
    ca_path = os.path.join(os.path.dirname(__file__), '../../ca.pem')
    if not os.path.exists(ca_path):
        print(f"❌ CA certificate not found at {ca_path}")
        print("Please download ca.pem from your Aiven dashboard and place it in the backend directory.")
        exit(1)
    ssl_context = ssl.create_default_context(cafile=ca_path)
    return ssl_context

async def test_connection():
    print(f"Trying: {DATABASE_URL}")
    ssl_context = get_ssl_context()
    engine = create_async_engine(
        DATABASE_URL or "bad_url",
        echo=True,
        connect_args={"ssl": ssl_context}
    )
    try:
        async with engine.begin() as conn:
            # FIX: wrap SQL string in text()
            await conn.execute(text("SELECT 1;"))
        print("✅ Database connection successful!")
    except SQLAlchemyError as e:
        print("❌ Database connection failed!")
        print(repr(e))

if __name__ == "__main__":
    asyncio.run(test_connection())



===============================================
File: app\db\models\__init__.py
===============================================

from .user import User
from .transaction import Transaction
from .debt import Debt
from .split_expense import SplitExpense
from .subscription import Subscription
from .budget import Budget
from .goal import Goal
from .saving import Saving
from .friend import Friend
from .message import Message
from .nudge import Nudge
from .permission import Permission
from .template import Template
from .widget_config import WidgetConfig

===============================================
File: app\db\models\budget.py
===============================================

from sqlalchemy import Column, Integer, String, Float, Date, DateTime
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base

class Budget(Base):
    __tablename__ = "budgets"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    category = Column(String, nullable=False)
    amount = Column(Float, nullable=False)
    period = Column(String, nullable=False)  # monthly/weekly
    start_date = Column(Date, nullable=False)
    end_date = Column(Date, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="budgets")

===============================================
File: app\db\models\debt.py
===============================================

from sqlalchemy import Column, Integer, String, Float, Date, DateTime, Enum
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base
import enum

class DebtStatus(enum.Enum):
    pending = "pending"
    paid = "paid"

class Debt(Base):
    __tablename__ = "debts"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    friend_id = Column(Integer, ForeignKey("friends.id"), index=True, nullable=True)
    amount = Column(Float, nullable=False)
    description = Column(String, nullable=True)
    due_date = Column(Date, nullable=True)
    status = Column(Enum(DebtStatus), nullable=False, default=DebtStatus.pending)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="debts")
    friend = relationship("Friend", back_populates="debts")

===============================================
File: app\db\models\friend.py
===============================================

from sqlalchemy import Column, Integer, String, Boolean, DateTime
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base

class Friend(Base):
    __tablename__ = "friends"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    name = Column(String, nullable=False)
    phone_number = Column(String, nullable=True)
    avatar_url = Column(String, nullable=True)
    is_online = Column(Boolean, default=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="friends")
    debts = relationship("Debt", back_populates="friend")
    messages = relationship("Message", back_populates="friend")

===============================================
File: app\db\models\goal.py
===============================================

from sqlalchemy import Column, Integer, String, Float, Date, DateTime
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base

class Goal(Base):
    __tablename__ = "goals"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    name = Column(String, nullable=False)
    target_amount = Column(Float, nullable=False)
    current_amount = Column(Float, nullable=False, default=0.0)
    target_date = Column(Date, nullable=False)
    category = Column(String, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="goals")
    savings = relationship("Saving", back_populates="goal")

===============================================
File: app\db\models\message.py
===============================================

from sqlalchemy import Column, Integer, String, Boolean, DateTime
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base

class Message(Base):
    __tablename__ = "messages"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    friend_id = Column(Integer, ForeignKey("friends.id"), nullable=True)
    content = Column(String, nullable=False)
    is_user = Column(Boolean, nullable=False)  # True for user, False for AI
    timestamp = Column(DateTime(timezone=True), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="messages")
    friend = relationship("Friend", back_populates="messages")

===============================================
File: app\db\models\nudge.py
===============================================

from sqlalchemy import Column, Integer, String, Enum, DateTime
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base
import enum

class NudgeStatus(enum.Enum):
    active = "active"
    dismissed = "dismissed"

class Nudge(Base):
    __tablename__ = "nudges"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    type = Column(String, nullable=False)  # e.g., debt_due, savings_goal
    content = Column(String, nullable=False)
    status = Column(Enum(NudgeStatus), nullable=False, default=NudgeStatus.active)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="nudges")

===============================================
File: app\db\models\permission.py
===============================================

from sqlalchemy import Column, Integer, String, DateTime
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base

class Permission(Base):
    __tablename__ = "permissions"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    resource_id = Column(Integer, nullable=False)
    resource_type = Column(String, nullable=False)  # e.g., split_expense, budget
    permission_type = Column(String, nullable=False)  # view/edit
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="permissions")

===============================================
File: app\db\models\saving.py
===============================================

from sqlalchemy import Column, Integer, String, Float, DateTime
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base

class Saving(Base):
    __tablename__ = "savings"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    name = Column(String, nullable=False)
    amount = Column(Float, nullable=False)
    goal_id = Column(Integer, ForeignKey("goals.id"), nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="savings")
    goal = relationship("Goal", back_populates="savings")

===============================================
File: app\db\models\split_expense.py
===============================================

from sqlalchemy import Column, Integer, String, Float, DateTime, Enum, JSON
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base
import enum

class SplitType(enum.Enum):
    equal = "equal"
    percentage = "percentage"
    custom = "custom"

class SplitExpense(Base):
    __tablename__ = "split_expenses"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    description = Column(String, nullable=False)
    total_amount = Column(Float, nullable=False)
    split_type = Column(Enum(SplitType), nullable=False)
    participants = Column(JSON, nullable=False)  # Stores list of {user_id, amount_paid, share_amount}
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="split_expenses")

===============================================
File: app\db\models\subscription.py
===============================================

from sqlalchemy import Column, Integer, String, Float, Date, DateTime, Enum
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base
import enum

class SubscriptionStatus(enum.Enum):
    active = "active"
    paused = "paused"
    cancelled = "cancelled"

class Subscription(Base):
    __tablename__ = "subscriptions"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    name = Column(String, nullable=False)
    amount = Column(Float, nullable=False)
    billing_cycle = Column(String, nullable=False)  # monthly/yearly/weekly
    next_due_date = Column(Date, nullable=False)
    category = Column(String, nullable=True)
    status = Column(Enum(SubscriptionStatus), nullable=False, default=SubscriptionStatus.active)
    color = Column(String, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="subscriptions")

===============================================
File: app\db\models\template.py
===============================================

from sqlalchemy import Column, Integer, String, Float, DateTime
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base

class Template(Base):
    __tablename__ = "templates"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    name = Column(String, nullable=False)
    category = Column(String, nullable=True)
    amount = Column(Float, nullable=True)
    description = Column(String, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="templates")

===============================================
File: app\db\models\transaction.py
===============================================

from sqlalchemy import Column, Integer, String, Float, DateTime, Enum
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base
import enum

class TransactionType(enum.Enum):
    expense = "expense"
    income = "income"

class Transaction(Base):
    __tablename__ = "transactions"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    amount = Column(Float, nullable=False)
    description = Column(String, nullable=True)
    category = Column(String, nullable=True)
    merchant_name = Column(String, nullable=True)
    bank_name = Column(String, nullable=True)
    confidence = Column(String, nullable=True)  # high/medium/low
    type = Column(Enum(TransactionType), nullable=False)
    timestamp = Column(DateTime(timezone=True), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="transactions")

===============================================
File: app\db\models\user.py
===============================================

from sqlalchemy import Column, String, Integer, DateTime
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from app.db.database import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, nullable=False)
    email = Column(String, unique=True, index=True, nullable=False)
    password_hash = Column(String, nullable=False)
    phone_number = Column(String, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    transactions = relationship("Transaction", back_populates="user")
    debts = relationship("Debt", back_populates="user")
    split_expenses = relationship("SplitExpense", back_populates="user")
    subscriptions = relationship("Subscription", back_populates="user")
    budgets = relationship("Budget", back_populates="user")
    goals = relationship("Goal", back_populates="user")
    savings = relationship("Saving", back_populates="user")
    friends = relationship("Friend", back_populates="user")
    messages = relationship("Message", back_populates="user")
    nudges = relationship("Nudge", back_populates="user")
    permissions = relationship("Permission", back_populates="user")
    templates = relationship("Template", back_populates="user")
    widget_configs = relationship("WidgetConfig", back_populates="user")

===============================================
File: app\db\models\widget_config.py
===============================================

from sqlalchemy import Column, Integer, String, JSON, DateTime
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from sqlalchemy.sql.schema import ForeignKey
from app.db.database import Base

class WidgetConfig(Base):
    __tablename__ = "widget_configs"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True, nullable=False)
    widget_type = Column(String, nullable=False)
    position = Column(Integer, nullable=False)
    settings = Column(JSON, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="widget_configs")


===============================================
File: app\db\schemas\__init__.py
===============================================

from .user import User, UserCreate
from .transaction import Transaction, TransactionCreate
from .debt import Debt, DebtCreate
from .split_expense import SplitExpense, SplitExpenseCreate
from .subscription import Subscription, SubscriptionCreate, SubscriptionUpdate
from .budget import Budget, BudgetCreate
from .goal import Goal, GoalCreate
from .saving import Saving, SavingCreate
from .friend import Friend, FriendCreate
from .message import Message, MessageCreate
from .nudge import Nudge, NudgeCreate
from .permission import Permission, PermissionCreate
from .template import Template, TemplateCreate
from .widget_config import WidgetConfig, WidgetConfigCreate

===============================================
File: app\db\schemas\budget.py
===============================================

from pydantic import BaseModel
from datetime import datetime, date
from typing import Optional

class BudgetBase(BaseModel):
    category: str
    amount: float
    period: str  # monthly/weekly
    start_date: date
    end_date: date

class BudgetCreate(BudgetBase):
    pass

class Budget(BudgetBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\debt.py
===============================================

from pydantic import BaseModel
from datetime import datetime, date
from typing import Optional
from enum import Enum

class DebtStatus(str, Enum):
    pending = "pending"
    paid = "paid"

class DebtBase(BaseModel):
    amount: float
    description: Optional[str] = None
    due_date: Optional[date] = None
    status: DebtStatus = DebtStatus.pending

class DebtCreate(DebtBase):
    friend_id: Optional[int] = None

class Debt(DebtBase):
    id: int
    user_id: int
    friend_id: Optional[int] = None
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\friend.py
===============================================

from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class FriendBase(BaseModel):
    name: str
    phone_number: Optional[str] = None
    avatar_url: Optional[str] = None
    is_online: bool = False

class FriendCreate(FriendBase):
    pass

class Friend(FriendBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\goal.py
===============================================

from pydantic import BaseModel
from datetime import datetime, date
from typing import Optional

class GoalBase(BaseModel):
    name: str
    target_amount: float
    current_amount: float = 0.0
    target_date: date
    category: Optional[str] = None

class GoalCreate(GoalBase):
    pass

class Goal(GoalBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\message.py
===============================================

from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class MessageBase(BaseModel):
    content: str
    is_user: bool
    timestamp: datetime

class MessageCreate(MessageBase):
    friend_id: Optional[int] = None

class Message(MessageBase):
    id: int
    user_id: int
    friend_id: Optional[int] = None
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\nudge.py
===============================================

from pydantic import BaseModel
from datetime import datetime
from typing import Optional
from enum import Enum

class NudgeStatus(str, Enum):
    active = "active"
    dismissed = "dismissed"

class NudgeBase(BaseModel):
    type: str  # e.g., debt_due, savings_goal
    content: str
    status: NudgeStatus = NudgeStatus.active

class NudgeCreate(NudgeBase):
    pass

class Nudge(NudgeBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\permission.py
===============================================

from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class PermissionBase(BaseModel):
    resource_id: int
    resource_type: str  # e.g., split_expense, budget
    permission_type: str  # view/edit

class PermissionCreate(PermissionBase):
    pass

class Permission(PermissionBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\saving.py
===============================================

from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class SavingBase(BaseModel):
    name: str
    amount: float
    goal_id: Optional[int] = None

class SavingCreate(SavingBase):
    pass

class Saving(SavingBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\split_expense.py
===============================================

from pydantic import BaseModel
from datetime import datetime
from typing import List, Dict, Optional
from enum import Enum

class SplitType(str, Enum):
    equal = "equal"
    percentage = "percentage"
    custom = "custom"

class SplitExpenseBase(BaseModel):
    description: str
    total_amount: float
    split_type: SplitType
    participants: List[Dict[str, float]]  # e.g., [{"user_id": 1, "amount_paid": 100, "share_amount": 50}]

class SplitExpenseCreate(SplitExpenseBase):
    pass

class SplitExpense(SplitExpenseBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\subscription.py
===============================================

from pydantic import BaseModel
from datetime import datetime, date
from typing import Optional
from enum import Enum

class SubscriptionStatus(str, Enum):
    active = "active"
    paused = "paused"
    cancelled = "cancelled"

class SubscriptionBase(BaseModel):
    name: str
    amount: float
    billing_cycle: str  # monthly/yearly/weekly
    next_due_date: date
    category: Optional[str] = None
    status: SubscriptionStatus = SubscriptionStatus.active
    color: Optional[str] = None

class SubscriptionCreate(SubscriptionBase):
    pass

class SubscriptionUpdate(SubscriptionBase):
    name: Optional[str] = None
    amount: Optional[float] = None
    billing_cycle: Optional[str] = None
    next_due_date: Optional[date] = None
    status: Optional[SubscriptionStatus] = None

class Subscription(SubscriptionBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\template.py
===============================================

from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class TemplateBase(BaseModel):
    name: str
    category: Optional[str] = None
    amount: Optional[float] = None
    description: Optional[str] = None

class TemplateCreate(TemplateBase):
    pass

class Template(TemplateBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\transaction.py
===============================================

from pydantic import BaseModel
from datetime import datetime
from typing import Optional
from enum import Enum

class TransactionType(str, Enum):
    expense = "expense"
    income = "income"

class TransactionBase(BaseModel):
    amount: float
    description: Optional[str] = None
    category: Optional[str] = None
    merchant_name: Optional[str] = None
    bank_name: Optional[str] = None
    confidence: Optional[str] = None  # high/medium/low
    type: TransactionType
    timestamp: datetime

class TransactionCreate(TransactionBase):
    pass

class Transaction(TransactionBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\user.py
===============================================

from pydantic import BaseModel, EmailStr
from datetime import datetime
from typing import Optional

class UserBase(BaseModel):
    username: str
    email: EmailStr
    phone_number: Optional[str] = None

class UserCreate(UserBase):
    password: str

class User(UserBase):
    id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

===============================================
File: app\db\schemas\widget_config.py
===============================================

from pydantic import BaseModel
from datetime import datetime
from typing import Optional, Dict

class WidgetConfigBase(BaseModel):
    widget_type: str
    position: int
    settings: Optional[Dict] = None

class WidgetConfigCreate(WidgetConfigBase):
    pass

class WidgetConfig(WidgetConfigBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True


===============================================
File: app\middleware\__init__.py
===============================================



===============================================
File: app\middleware\auth.py
===============================================



===============================================
File: app\services\__init__.py
===============================================



===============================================
File: app\services\analytics_service.py
===============================================



===============================================
File: app\services\auth_service.py
===============================================



===============================================
File: app\services\budget_service.py
===============================================



===============================================
File: app\services\chat_service.py
===============================================



===============================================
File: app\services\debt_service.py
===============================================



===============================================
File: app\services\friend_service.py
===============================================



===============================================
File: app\services\goal_service.py
===============================================



===============================================
File: app\services\message_service.py
===============================================



===============================================
File: app\services\notification_service.py
===============================================



===============================================
File: app\services\split_service.py
===============================================



===============================================
File: app\services\subscription_service.py
===============================================



===============================================
File: app\services\transaction_service.py
===============================================



===============================================
File: app\utils\__init__.py
===============================================



===============================================
File: app\utils\helpers.py
===============================================



===============================================
File: tests\__init__.py
===============================================



===============================================
File: tests\test_analytics.py
===============================================

import pytest
import pytest_asyncio
from fastapi.testclient import TestClient
from fastapi import status
from app.db.database import get_db
from sqlalchemy.orm import Session
from app.db.models.user import User
from main import app

@pytest_asyncio.fixture
async def client():
    return TestClient(app)

@pytest_asyncio.fixture
async def db_session():
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()

@pytest_asyncio.fixture
async def test_user(db_session: Session):
    user = db_session.query(User).filter(User.email == "test@example.com").first()
    if not user:
        user = User(
            username="testuser",
            email="test@example.com",
            password_hash="$2b$12$wHbQTgJT92Cnbzbp5/W3n.ud.JLZClxFPZIXuEsyWmGrBVX62pl6W",
            phone_number="1234567890"
        )
        db_session.add(user)
        db_session.commit()
    return user

@pytest.mark.asyncio
async def test_get_analytics(client: TestClient, test_user: User):
    response = client.get(f"/analytics?user_id={test_user.id}")
    assert response.status_code == status.HTTP_200_OK
    assert "spending_by_category" in response.json()
    assert "total_expenses" in response.json()

===============================================
File: tests\test_auth.py
===============================================

import pytest
import pytest_asyncio
from fastapi.testclient import TestClient
from fastapi import status
from app.db.database import get_db
from sqlalchemy.orm import Session
from app.db.models.user import User
from app.db.schemas.user import UserCreate
from main import app

@pytest_asyncio.fixture
async def client():
    return TestClient(app)

@pytest_asyncio.fixture
async def db_session():
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()

@pytest_asyncio.fixture
async def test_user(db_session: Session):
    user = db_session.query(User).filter(User.email == "test@example.com").first()
    if not user:
        user = User(
            username="testuser",
            email="test@example.com",
            password_hash="$2b$12$wHbQTgJT92Cnbzbp5/W3n.ud.JLZClxFPZIXuEsyWmGrBVX62pl6W",
            phone_number="1234567890"
        )
        db_session.add(user)
        db_session.commit()
    return user

@pytest.mark.asyncio
async def test_signup_success(client: TestClient, db_session: Session):
    db_session.query(User).filter(User.email == "newuser@example.com").delete()
    db_session.commit()
    user_data = {
        "username": "newuser",
        "email": "newuser@example.com",
        "password": "password123",
        "phone_number": "9876543210"
    }
    response = client.post("/auth/signup", json=user_data)
    assert response.status_code == status.HTTP_201_CREATED
    assert response.json()["email"] == "newuser@example.com"
    db_user = db_session.query(User).filter(User.email == "newuser@example.com").first()
    assert db_user is not None
    assert db_user.username == "newuser"

@pytest.mark.asyncio
async def test_signup_duplicate_email(client: TestClient):
    user_data = {
        "username": "testuser",
        "email": "test@example.com",
        "password": "testpassword123",
        "phone_number": "9876543210"
    }
    response = client.post("/auth/signup", json=user_data)
    assert response.status_code == status.HTTP_400_BAD_REQUEST
    assert "already registered" in response.json()["detail"]

@pytest.mark.asyncio
async def test_login_success(client: TestClient):
    login_data = {
        "username": "testuser",
        "email": "test@example.com",
        "password": "testpassword123",
        "phone_number": "1234567890"
    }
    response = client.post("/auth/login", json=login_data)
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["message"] == "Login successful"
    assert "user_id" in response.json()

@pytest.mark.asyncio
async def test_login_invalid_credentials(client: TestClient):
    login_data = {
        "username": "testuser",
        "email": "test@example.com",
        "password": "wrongpassword",
        "phone_number": "1234567890"
    }
    response = client.post("/auth/login", json=login_data)
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "Invalid email or password" in response.json()["detail"]

===============================================
File: tests\test_budgets.py
===============================================

import pytest
import pytest_asyncio
from fastapi.testclient import TestClient
from fastapi import status
from app.db.database import get_db
from sqlalchemy.orm import Session
from app.db.models.user import User
from main import app

@pytest_asyncio.fixture
async def client():
    return TestClient(app)

@pytest_asyncio.fixture
async def db_session():
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()

@pytest_asyncio.fixture
async def test_user(db_session: Session):
    user = db_session.query(User).filter(User.email == "test@example.com").first()
    if not user:
        user = User(
            username="testuser",
            email="test@example.com",
            password_hash="$2b$12$wHbQTgJT92Cnbzbp5/W3n.ud.JLZClxFPZIXuEsyWmGrBVX62pl6W",
            phone_number="1234567890"
        )
        db_session.add(user)
        db_session.commit()
    return user

@pytest.mark.asyncio
async def test_get_analytics(client: TestClient, test_user: User):
    response = client.get(f"/analytics?user_id={test_user.id}")
    assert response.status_code == status.HTTP_200_OK
    assert "spending_by_category" in response.json()
    assert "total_expenses" in response.json()

===============================================
File: tests\test_chat.py
===============================================

import pytest
import pytest_asyncio
from fastapi.testclient import TestClient
from fastapi import status
from app.db.database import get_db
from sqlalchemy.orm import Session
from app.db.models.user import User
from main import app

@pytest_asyncio.fixture
async def client():
    return TestClient(app)

@pytest_asyncio.fixture
async def db_session():
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()

@pytest_asyncio.fixture
async def test_user(db_session: Session):
    user = db_session.query(User).filter(User.email == "test@example.com").first()
    if not user:
        user = User(
            username="testuser",
            email="test@example.com",
            password_hash="$2b$12$wHbQTgJT92Cnbzbp5/W3n.ud.JLZClxFPZIXuEsyWmGrBVX62pl6W",
            phone_number="1234567890"
        )
        db_session.add(user)
        db_session.commit()
    return user

@pytest.mark.asyncio
async def test_send_chat_message(client: TestClient, test_user: User):
    chat_data = {
        "user_id": test_user.id,
        "message": "How’s my spending looking this week?"
    }
    response = client.post("/chat", json=chat_data)
    assert response.status_code == status.HTTP_200_OK
    assert "response" in response.json()
    assert response.json()["user_id"] == test_user.id

===============================================
File: tests\test_debts.py
===============================================

import pytest
import pytest_asyncio
from fastapi.testclient import TestClient
from fastapi import status
from app.db.database import get_db
from sqlalchemy.orm import Session
from app.db.models.user import User
from app.db.models.debt import Debt
from app.db.schemas.debt import DebtCreate, Debt as DebtSchema
from main import app

@pytest_asyncio.fixture
async def client():
    return TestClient(app)

@pytest_asyncio.fixture
async def db_session():
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()

@pytest_asyncio.fixture
async def test_user(db_session: Session):
    user = db_session.query(User).filter(User.email == "test@example.com").first()
    if not user:
        user = User(
            username="testuser",
            email="test@example.com",
            password_hash="$2b$12$wHbQTgJT92Cnbzbp5/W3n.ud.JLZClxFPZIXuEsyWmGrBVX62pl6W",
            phone_number="1234567890"
        )
        db_session.add(user)
        db_session.commit()
    return user

@pytest.mark.asyncio
async def test_create_debt(client: TestClient, db_session: Session, test_user: User):
    debt_data = {
        "user_id": test_user.id,
        "creditor_id": test_user.id,
        "amount": 200.00,
        "description": "Lunch debt"
    }
    response = client.post("/debts", json=debt_data)
    assert response.status_code == status.HTTP_201_CREATED
    assert response.json()["amount"] == 200.00
    db_debt = db_session.query(Debt).filter(Debt.description == "Lunch debt").first()
    assert db_debt is not None
    assert db_debt.user_id == test_user.id

@pytest.mark.asyncio
async def test_get_debts(client: TestClient, db_session: Session, test_user: User):
    debt = Debt(
        user_id=test_user.id,
        creditor_id=test_user.id,
        amount=300.00,
        description="Movie debt"
    )
    db_session.add(debt)
    db_session.commit()
    response = client.get(f"/debts?user_id={test_user.id}")
    assert response.status_code == status.HTTP_200_OK
    assert len(response.json()) >= 1
    assert any(d["description"] == "Movie debt" for d in response.json())

@pytest.mark.asyncio
async def test_settle_debt(client: TestClient, db_session: Session, test_user: User):
    debt = Debt(
        user_id=test_user.id,
        creditor_id=test_user.id,
        amount=100.00,
        description="Coffee debt"
    )
    db_session.add(debt)
    db_session.commit()
    response = client.post(f"/debts/{debt.id}/settle")
    assert response.status_code == status.HTTP_200_OK
    db_debt = db_session.query(Debt).filter(Debt.id == debt.id).first()
    assert db_debt is None

===============================================
File: tests\test_friends.py
===============================================

import pytest
import pytest_asyncio
from fastapi.testclient import TestClient
from fastapi import status
from app.db.database import get_db
from sqlalchemy.orm import Session
from app.db.models.user import User
from app.db.models.friend import Friend
from app.db.schemas.friend import FriendCreate, Friend as FriendSchema
from main import app

@pytest_asyncio.fixture
async def client():
    return TestClient(app)

@pytest_asyncio.fixture
async def db_session():
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()

@pytest_asyncio.fixture
async def test_user(db_session: Session):
    user = db_session.query(User).filter(User.email == "test@example.com").first()
    if not user:
        user = User(
            username="testuser",
            email="test@example.com",
            password_hash="$2b$12$wHbQTgJT92Cnbzbp5/W3n.ud.JLZClxFPZIXuEsyWmGrBVX62pl6W",
            phone_number="1234567890"
        )
        db_session.add(user)
        db_session.commit()
    return user

@pytest.mark.asyncio
async def test_add_friend(client: TestClient, db_session: Session, test_user: User):
    friend_data = {
        "user_id": test_user.id,
        "friend_id": test_user.id  # Self for simplicity
    }
    response = client.post("/friends", json=friend_data)
    assert response.status_code == status.HTTP_201_CREATED
    db_friend = db_session.query(Friend).filter(Friend.user_id == test_user.id).first()
    assert db_friend is not None
    assert db_friend.friend_id == test_user.id

@pytest.mark.asyncio
async def test_get_friends(client: TestClient, db_session: Session, test_user: User):
    friend = Friend(user_id=test_user.id, friend_id=test_user.id)
    db_session.add(friend)
    db_session.commit()
    response = client.get(f"/friends?user_id={test_user.id}")
    assert response.status_code == status.HTTP_200_OK
    assert len(response.json()) >= 1
    assert any(f["friend_id"] == test_user.id for f in response.json())

===============================================
File: tests\test_goals.py
===============================================

import pytest
import pytest_asyncio
from fastapi.testclient import TestClient
from fastapi import status
from app.db.database import get_db
from sqlalchemy.orm import Session
from app.db.models.user import User
from app.db.models.goal import Goal
from app.db.schemas.goal import GoalCreate, Goal as GoalSchema
from main import app

@pytest_asyncio.fixture
async def client():
    return TestClient(app)

@pytest_asyncio.fixture
async def db_session():
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()

@pytest_asyncio.fixture
async def test_user(db_session: Session):
    user = db_session.query(User).filter(User.email == "test@example.com").first()
    if not user:
        user = User(
            username="testuser",
            email="test@example.com",
            password_hash="$2b$12$wHbQTgJT92Cnbzbp5/W3n.ud.JLZClxFPZIXuEsyWmGrBVX62pl6W",
            phone_number="1234567890"
        )
        db_session.add(user)
        db_session.commit()
    return user

@pytest.mark.asyncio
async def test_create_goal(client: TestClient, db_session: Session, test_user: User):
    goal_data = {
        "user_id": test_user.id,
        "title": "Vacation Fund",
        "target_amount": 5000.00,
        "current_amount": 1000.00
    }
    response = client.post("/goals", json=goal_data)
    assert response.status_code == status.HTTP_201_CREATED
    assert response.json()["title"] == "Vacation Fund"
    db_goal = db_session.query(Goal).filter(Goal.title == "Vacation Fund").first()
    assert db_goal is not None
    assert db_goal.user_id == test_user.id

@pytest.mark.asyncio
async def test_get_goals(client: TestClient, db_session: Session, test_user: User):
    goal = Goal(
        user_id=test_user.id,
        title="Car Fund",
        target_amount=10000.00,
        current_amount=2000.00
    )
    db_session.add(goal)
    db_session.commit()
    response = client.get(f"/goals?user_id={test_user.id}")
    assert response.status_code == status.HTTP_200_OK
    assert len(response.json()) >= 1
    assert any(g["title"] == "Car Fund" for g in response.json())

@pytest.mark.asyncio
async def test_update_goal(client: TestClient, db_session: Session, test_user: User):
    goal = Goal(
        user_id=test_user.id,
        title="Bike Fund",
        target_amount=2000.00,
        current_amount=500.00
    )
    db_session.add(goal)
    db_session.commit()
    update_data = {
        "current_amount": 600.00
    }
    response = client.put(f"/goals/{goal.id}", json=update_data)
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["current_amount"] == 600.00

===============================================
File: tests\test_messages.py
===============================================

import pytest
import pytest_asyncio
from fastapi.testclient import TestClient
from fastapi import status
from app.db.database import get_db
from sqlalchemy.orm import Session
from app.db.models.user import User
from app.db.models.message import Message
from app.db.schemas.message import MessageCreate, Message as MessageSchema
from main import app

@pytest_asyncio.fixture
async def client():
    return TestClient(app)

@pytest_asyncio.fixture
async def db_session():
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()

@pytest_asyncio.fixture
async def test_user(db_session: Session):
    user = db_session.query(User).filter(User.email == "test@example.com").first()
    if not user:
        user = User(
            username="testuser",
            email="test@example.com",
            password_hash="$2b$12$wHbQTgJT92Cnbzbp5/W3n.ud.JLZClxFPZIXuEsyWmGrBVX62pl6W",
            phone_number="1234567890"
        )
        db_session.add(user)
        db_session.commit()
    return user

@pytest.mark.asyncio
async def test_send_message(client: TestClient, db_session: Session, test_user: User):
    message_data = {
        "sender_id": test_user.id,
        "receiver_id": test_user.id,
        "content": "Hey, let’s split the bill!"
    }
    response = client.post("/messages", json=message_data)
    assert response.status_code == status.HTTP_201_CREATED
    assert response.json()["content"] == "Hey, let’s split the bill!"
    db_message = db_session.query(Message).filter(Message.content == "Hey, let’s split the bill!").first()
    assert db_message is not None
    assert db_message.sender_id == test_user.id

@pytest.mark.asyncio
async def test_get_messages(client: TestClient, db_session: Session, test_user: User):
    message = Message(
        sender_id=test_user.id,
        receiver_id=test_user.id,
        content="Pay me back for lunch!"
    )
    db_session.add(message)
    db_session.commit()
    response = client.get(f"/messages?user_id={test_user.id}")
    assert response.status_code == status.HTTP_200_OK
    assert len(response.json()) >= 1
    assert any(m["content"] == "Pay me back for lunch!" for m in response.json())

===============================================
File: tests\test_notifications.py
===============================================

import pytest
import pytest_asyncio
from fastapi.testclient import TestClient
from fastapi import status
from app.db.database import get_db
from sqlalchemy.orm import Session
from app.db.models.user import User
from app.db.models.nudge import Nudge
from app.db.schemas.nudge import NudgeCreate, Nudge as NudgeSchema
from main import app

@pytest_asyncio.fixture
async def client():
    return TestClient(app)

@pytest_asyncio.fixture
async def db_session():
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()

@pytest_asyncio.fixture
async def test_user(db_session: Session):
    user = db_session.query(User).filter(User.email == "test@example.com").first()
    if not user:
        user = User(
            username="testuser",
            email="test@example.com",
            password_hash="$2b$12$wHbQTgJT92Cnbzbp5/W3n.ud.JLZClxFPZIXuEsyWmGrBVX62pl6W",
            phone_number="1234567890"
        )
        db_session.add(user)
        db_session.commit()
    return user

@pytest.mark.asyncio
async def test_get_notifications(client: TestClient, db_session: Session, test_user: User):
    nudge = Nudge(
        user_id=test_user.id,
        message="You overspent on Food this week!",
        type="alert"
    )
    db_session.add(nudge)
    db_session.commit()
    response = client.get(f"/notifications?user_id={test_user.id}")
    assert response.status_code == status.HTTP_200_OK
    assert len(response.json()) >= 1
    assert any(n["message"] == "You overspent on Food this week!" for n in response.json())

@pytest.mark.asyncio
async def test_mark_notification_read(client: TestClient, db_session: Session, test_user: User):
    nudge = Nudge(
        user_id=test_user.id,
        message="Budget alert!",
        type="alert"
    )
    db_session.add(nudge)
    db_session.commit()
    response = client.post(f"/notifications/{nudge.id}/mark-read")
    assert response.status_code == status.HTTP_200_OK
    db_nudge = db_session.query(Nudge).filter(Nudge.id == nudge.id).first()
    assert db_nudge.is_read is True

===============================================
File: tests\test_nudges.py
===============================================

import pytest
import pytest_asyncio
from fastapi.testclient import TestClient
from fastapi import status
from app.db.database import get_db
from sqlalchemy.orm import Session
from app.db.models.user import User
from app.db.models.nudge import Nudge
from app.db.schemas.nudge import NudgeCreate, Nudge as NudgeSchema
from main import app

@pytest_asyncio.fixture
async def client():
    return TestClient(app)

@pytest_asyncio.fixture
async def db_session():
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()

@pytest_asyncio.fixture
async def test_user(db_session: Session):
    user = db_session.query(User).filter(User.email == "test@example.com").first()
    if not user:
        user = User(
            username="testuser",
            email="test@example.com",
            password_hash="$2b$12$wHbQTgJT92Cnbzbp5/W3n.ud.JLZClxFPZIXuEsyWmGrBVX62pl6W",
            phone_number="1234567890"
        )
        db_session.add(user)
        db_session.commit()
    return user

@pytest.mark.asyncio
async def test_create_nudge(client: TestClient, db_session: Session, test_user: User):
    nudge_data = {
        "user_id": test_user.id,
        "message": "Save more this week!",
        "type": "motivation"
    }
    response = client.post("/nudges", json=nudge_data)
    assert response.status_code == status.HTTP_201_CREATED
    assert response.json()["message"] == "Save more this week!"
    db_nudge = db_session.query(Nudge).filter(Nudge.message == "Save more this week!").first()
    assert db_nudge is not None
    assert db_nudge.user_id == test_user.id

@pytest.mark.asyncio
async def test_get_nudges(client: TestClient, db_session: Session, test_user: User):
    nudge = Nudge(
        user_id=test_user.id,
        message="Check your budget!",
        type="alert"
    )
    db_session.add(nudge)
    db_session.commit()
    response = client.get(f"/nudges?user_id={test_user.id}")
    assert response.status_code == status.HTTP_200_OK
    assert len(response.json()) >= 1
    assert any(n["message"] == "Check your budget!" for n in response.json())

===============================================
File: tests\test_receipts.py
===============================================

import pytest
import pytest_asyncio
from fastapi.testclient import TestClient
from fastapi import status
from app.db.database import get_db
from sqlalchemy.orm import Session
from app.db.models.user import User
from app.db.models.nudge import Nudge
from app.db.schemas.nudge import NudgeCreate, Nudge as NudgeSchema
from main import app

@pytest_asyncio.fixture
async def client():
    return TestClient(app)

@pytest_asyncio.fixture
async def db_session():
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()

@pytest_asyncio.fixture
async def test_user(db_session: Session):
    user = db_session.query(User).filter(User.email == "test@example.com").first()
    if not user:
        user = User(
            username="testuser",
            email="test@example.com",
            password_hash="$2b$12$wHbQTgJT92Cnbzbp5/W3n.ud.JLZClxFPZIXuEsyWmGrBVX62pl6W",
            phone_number="1234567890"
        )
        db_session.add(user)
        db_session.commit()
    return user

@pytest.mark.asyncio
async def test_get_notifications(client: TestClient, db_session: Session, test_user: User):
    nudge = Nudge(
        user_id=test_user.id,
        message="You overspent on Food this week!",
        type="alert"
    )
    db_session.add(nudge)
    db_session.commit()
    response = client.get(f"/notifications?user_id={test_user.id}")
    assert response.status_code == status.HTTP_200_OK
    assert len(response.json()) >= 1
    assert any(n["message"] == "You overspent on Food this week!" for n in response.json())

@pytest.mark.asyncio
async def test_mark_notification_read(client: TestClient, db_session: Session, test_user: User):
    nudge = Nudge(
        user_id=test_user.id,
        message="Budget alert!",
        type="alert"
    )
    db_session.add(nudge)
    db_session.commit()
    response = client.post(f"/notifications/{nudge.id}/mark-read")
    assert response.status_code == status.HTTP_200_OK
    db_nudge = db_session.query(Nudge).filter(Nudge.id == nudge.id).first()
    assert db_nudge.is_read is True

===============================================
File: tests\test_savings.py
===============================================

import pytest
import pytest_asyncio
from fastapi.testclient import TestClient
from fastapi import status
from app.db.database import get_db
from sqlalchemy.orm import Session
from app.db.models.user import User
from app.db.models.saving import Saving
from app.db.schemas.saving import SavingCreate, Saving as SavingSchema
from main import app

@pytest_asyncio.fixture
async def client():
    return TestClient(app)

@pytest_asyncio.fixture
async def db_session():
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()

@pytest_asyncio.fixture
async def test_user(db_session: Session):
    user = db_session.query(User).filter(User.email == "test@example.com").first()
    if not user:
        user = User(
            username="testuser",
            email="test@example.com",
            password_hash="$2b$12$wHbQTgJT92Cnbzbp5/W3n.ud.JLZClxFPZIXuEsyWmGrBVX62pl6W",
            phone_number="1234567890"
        )
        db_session.add(user)
        db_session.commit()
    return user

@pytest.mark.asyncio
async def test_create_saving(client: TestClient, db_session: Session, test_user: User):
    saving_data = {
        "user_id": test_user.id,
        "amount": 1000.00,
        "description": "Emergency Fund"
    }
    response = client.post("/savings", json=saving_data)
    assert response.status_code == status.HTTP_201_CREATED
    assert response.json()["amount"] == 1000.00
    db_saving = db_session.query(Saving).filter(Saving.description == "Emergency Fund").first()
    assert db_saving is not None
    assert db_saving.user_id == test_user.id

@pytest.mark.asyncio
async def test_get_savings(client: TestClient, db_session: Session, test_user: User):
    saving = Saving(
        user_id=test_user.id,
        amount=2000.00,
        description="Travel Fund"
    )
    db_session.add(saving)
    db_session.commit()
    response = client.get(f"/savings?user_id={test_user.id}")
    assert response.status_code == status.HTTP_200_OK
    assert len(response.json()) >= 1
    assert any(s["description"] == "Travel Fund" for s in response.json())

===============================================
File: tests\test_sms.py
===============================================

import pytest
import pytest_asyncio
from fastapi.testclient import TestClient
from fastapi import status
from app.db.database import get_db
from sqlalchemy.orm import Session
from app.db.models.user import User
from main import app

@pytest_asyncio.fixture
async def client():
    return TestClient(app)

@pytest_asyncio.fixture
async def db_session():
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()

@pytest_asyncio.fixture
async def test_user(db_session: Session):
    user = db_session.query(User).filter(User.email == "test@example.com").first()
    if not user:
        user = User(
            username="testuser",
            email="test@example.com",
            password_hash="$2b$12$wHbQTgJT92Cnbzbp5/W3n.ud.JLZClxFPZIXuEsyWmGrBVX62pl6W",
            phone_number="1234567890"
        )
        db_session.add(user)
        db_session.commit()
    return user

@pytest.mark.asyncio
async def test_send_sms(client: TestClient, test_user: User):
    sms_data = {
        "user_id": test_user.id,
        "message": "Your budget is low!"
    }
    response = client.post("/sms", json=sms_data)
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["status"] == "sent"

===============================================
File: tests\test_split_expenses.py
===============================================

import pytest
import pytest_asyncio
from fastapi.testclient import TestClient
from fastapi import status
from app.db.database import get_db
from sqlalchemy.orm import Session
from app.db.models.user import User
from app.db.models.split_expense import SplitExpense
from app.db.schemas.split_expense import SplitExpenseCreate, SplitExpense as SplitExpenseSchema
from main import app

@pytest_asyncio.fixture
async def client():
    return TestClient(app)

@pytest_asyncio.fixture
async def db_session():
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()

@pytest_asyncio.fixture
async def test_user(db_session: Session):
    user = db_session.query(User).filter(User.email == "test@example.com").first()
    if not user:
        user = User(
            username="testuser",
            email="test@example.com",
            password_hash="$2b$12$wHbQTgJT92Cnbzbp5/W3n.ud.JLZClxFPZIXuEsyWmGrBVX62pl6W",
            phone_number="1234567890"
        )
        db_session.add(user)
        db_session.commit()
    return user

@pytest.mark.asyncio
async def test_create_split_expense(client: TestClient, db_session: Session, test_user: User):
    split_data = {
        "user_id": test_user.id,
        "total_amount": 300.00,
        "description": "Dinner split",
        "participants": [test_user.id]
    }
    response = client.post("/split-expenses", json=split_data)
    assert response.status_code == status.HTTP_201_CREATED
    assert response.json()["total_amount"] == 300.00
    db_split = db_session.query(SplitExpense).filter(SplitExpense.description == "Dinner split").first()
    assert db_split is not None
    assert db_split.user_id == test_user.id

@pytest.mark.asyncio
async def test_get_split_expenses(client: TestClient, db_session: Session, test_user: User):
    split = SplitExpense(
        user_id=test_user.id,
        total_amount=150.00,
        description="Lunch split",
        participants=[test_user.id]
    )
    db_session.add(split)
    db_session.commit()
    response = client.get(f"/split-expenses?user_id={test_user.id}")
    assert response.status_code == status.HTTP_200_OK
    assert len(response.json()) >= 1
    assert any(s["description"] == "Lunch split" for s in response.json())

===============================================
File: tests\test_subscriptions.py
===============================================

import pytest
import pytest_asyncio
from fastapi.testclient import TestClient
from fastapi import status
from app.db.database import get_db
from sqlalchemy.orm import Session
from app.db.models.user import User
from app.db.models.subscription import Subscription
from app.db.schemas.subscription import SubscriptionCreate, Subscription as SubscriptionSchema
from main import app

@pytest_asyncio.fixture
async def client():
    return TestClient(app)

@pytest_asyncio.fixture
async def db_session():
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()

@pytest_asyncio.fixture
async def test_user(db_session: Session):
    user = db_session.query(User).filter(User.email == "test@example.com").first()
    if not user:
        user = User(
            username="testuser",
            email="test@example.com",
            password_hash="$2b$12$wHbQTgJT92Cnbzbp5/W3n.ud.JLZClxFPZIXuEsyWmGrBVX62pl6W",
            phone_number="1234567890"
        )
        db_session.add(user)
        db_session.commit()
    return user

@pytest.mark.asyncio
async def test_create_subscription(client: TestClient, db_session: Session, test_user: User):
    subscription_data = {
        "user_id": test_user.id,
        "service_name": "Netflix",
        "amount": 15.00,
        "renewal_date": "2025-09-01"
    }
    response = client.post("/subscriptions", json=subscription_data)
    assert response.status_code == status.HTTP_201_CREATED
    assert response.json()["service_name"] == "Netflix"
    db_subscription = db_session.query(Subscription).filter(Subscription.service_name == "Netflix").first()
    assert db_subscription is not None
    assert db_subscription.user_id == test_user.id

@pytest.mark.asyncio
async def test_get_subscriptions(client: TestClient, db_session: Session, test_user: User):
    subscription = Subscription(
        user_id=test_user.id,
        service_name="Spotify",
        amount=10.00,
        renewal_date="2025-09-01"
    )
    db_session.add(subscription)
    db_session.commit()
    response = client.get(f"/subscriptions?user_id={test_user.id}")
    assert response.status_code == status.HTTP_200_OK
    assert len(response.json()) >= 1
    assert any(s["service_name"] == "Spotify" for s in response.json())

===============================================
File: tests\test_templates.py
===============================================

import pytest
import pytest_asyncio
from fastapi.testclient import TestClient
from fastapi import status
from app.db.database import get_db
from sqlalchemy.orm import Session
from app.db.models.user import User
from app.db.models.subscription import Subscription
from app.db.schemas.subscription import SubscriptionCreate, Subscription as SubscriptionSchema
from main import app

@pytest_asyncio.fixture
async def client():
    return TestClient(app)

@pytest_asyncio.fixture
async def db_session():
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()

@pytest_asyncio.fixture
async def test_user(db_session: Session):
    user = db_session.query(User).filter(User.email == "test@example.com").first()
    if not user:
        user = User(
            username="testuser",
            email="test@example.com",
            password_hash="$2b$12$wHbQTgJT92Cnbzbp5/W3n.ud.JLZClxFPZIXuEsyWmGrBVX62pl6W",
            phone_number="1234567890"
        )
        db_session.add(user)
        db_session.commit()
    return user

@pytest.mark.asyncio
async def test_create_subscription(client: TestClient, db_session: Session, test_user: User):
    subscription_data = {
        "user_id": test_user.id,
        "service_name": "Netflix",
        "amount": 15.00,
        "renewal_date": "2025-09-01"
    }
    response = client.post("/subscriptions", json=subscription_data)
    assert response.status_code == status.HTTP_201_CREATED
    assert response.json()["service_name"] == "Netflix"
    db_subscription = db_session.query(Subscription).filter(Subscription.service_name == "Netflix").first()
    assert db_subscription is not None
    assert db_subscription.user_id == test_user.id

@pytest.mark.asyncio
async def test_get_subscriptions(client: TestClient, db_session: Session, test_user: User):
    subscription = Subscription(
        user_id=test_user.id,
        service_name="Spotify",
        amount=10.00,
        renewal_date="2025-09-01"
    )
    db_session.add(subscription)
    db_session.commit()
    response = client.get(f"/subscriptions?user_id={test_user.id}")
    assert response.status_code == status.HTTP_200_OK
    assert len(response.json()) >= 1
    assert any(s["service_name"] == "Spotify" for s in response.json())

===============================================
File: tests\test_transactions.py
===============================================

import pytest
import pytest_asyncio
from fastapi.testclient import TestClient
from fastapi import status
from app.db.database import get_db
from sqlalchemy.orm import Session
from app.db.models.user import User
from app.db.schemas.user import UserCreate
from main import app

@pytest_asyncio.fixture
async def client():
    return TestClient(app)

@pytest_asyncio.fixture
async def db_session():
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()

@pytest_asyncio.fixture
async def test_user(db_session: Session):
    user = db_session.query(User).filter(User.email == "test@example.com").first()
    if not user:
        user = User(
            username="testuser",
            email="test@example.com",
            password_hash="$2b$12$wHbQTgJT92Cnbzbp5/W3n.ud.JLZClxFPZIXuEsyWmGrBVX62pl6W",
            phone_number="1234567890"
        )
        db_session.add(user)
        db_session.commit()
    return user

@pytest.mark.asyncio
async def test_signup_success(client: TestClient, db_session: Session):
    db_session.query(User).filter(User.email == "newuser@example.com").delete()
    db_session.commit()
    user_data = {
        "username": "newuser",
        "email": "newuser@example.com",
        "password": "password123",
        "phone_number": "9876543210"
    }
    response = client.post("/auth/signup", json=user_data)
    assert response.status_code == status.HTTP_201_CREATED
    assert response.json()["email"] == "newuser@example.com"
    db_user = db_session.query(User).filter(User.email == "newuser@example.com").first()
    assert db_user is not None
    assert db_user.username == "newuser"

@pytest.mark.asyncio
async def test_signup_duplicate_email(client: TestClient):
    user_data = {
        "username": "testuser",
        "email": "test@example.com",
        "password": "testpassword123",
        "phone_number": "9876543210"
    }
    response = client.post("/auth/signup", json=user_data)
    assert response.status_code == status.HTTP_400_BAD_REQUEST
    assert "already registered" in response.json()["detail"]

@pytest.mark.asyncio
async def test_login_success(client: TestClient):
    login_data = {
        "username": "testuser",
        "email": "test@example.com",
        "password": "testpassword123",
        "phone_number": "1234567890"
    }
    response = client.post("/auth/login", json=login_data)
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["message"] == "Login successful"
    assert "user_id" in response.json()

@pytest.mark.asyncio
async def test_login_invalid_credentials(client: TestClient):
    login_data = {
        "username": "testuser",
        "email": "test@example.com",
        "password": "wrongpassword",
        "phone_number": "1234567890"
    }
    response = client.post("/auth/login", json=login_data)
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "Invalid email or password" in response.json()["detail"]

